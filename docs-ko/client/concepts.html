<template name="concepts">

<h1 id="concepts">Concepts</h1>

우리는 맨손으로 페이지 하나 짜리 JavaScript 앱을 수도 없이 만들어 왔다.
언어 하나(JavaScript)와 데이터 포멧 하나(JSON)로 앱 전체를 개발하는
것은 하염없이 기쁜 일이다. Meteor에는 앱을 개발하면서 우리가 바랬던 모든
것이 들어 있다.

{{> structure }}
{{> data }}
{{> reactivity }}
{{> livehtml }}
{{> templates }}
{{> packages_concept }}
{{> deploying }}
</template>

<template name="structure">
{{#better_markdown}}

<h2 id="structuringyourapp">Structuring your application</h2>

Meteor 앱은 브라우저가 실행하는 클라이언트 JavaScript와 Node.js 컨테이너가
실행하는 서버 JavaScript가 한데 섞여 있다. HTML 파일, CSS 파일, 그 외의 정적
파일도 함께 섞여 있다. 이 모든 파일을 패키징하고 배포하는 일을 Meteor가
모두 자동화했다. 어느 디렉토리에 해당 파일을 넣을지에 대한 제약은 거의
없다. 자유롭게 넣으면 된다.

서버 쪽 컴포넌트는 JavaScript 뿐이다. Meteor는 `client`와 `public` 디렉토리에
있는 파일을 제외한 나머지 JavaScript 파일을 모아서 Fiber Node.js 서버를
실행한다. Meteor는 요청 당 쓰레드 하나로 실행한다. Node의 비동기 콜백
스타일은 사용하지 않는다. Meteor 앱의 서버 코드에는 순차적 실행 모델이
더 낫다.

클라이언트는 더 다양한 컴포넌트를 사용한다. Meteor는 `server`와 
`public` 디렉토리를 제외한 나머지 JavaScript 코드를 한데 모아서 
클라이언트 쪽 JavaScript 코드로 사용한다. 이렇게 모은 번들을 minify해서 
클라이언트에 전송한다. 따라서 JavaScript 파일 하나만으로 앱을 개발해도 
되고 파일을 여러 개로 쪼개서 개발해도 된다.

`client`와 `server` 디렉토리 밖에 있는 파일들은 클라이언트와 서버 모두에서
사용한다. 모델 파일이나 공통 파일에 적합한 장소다. Meteor는
[`is_client`와 `is_server`](#meteor_is_client) 프로퍼티를 제공하기 때문에
해당 코드가 클라이언트에서 실행할 코드인지 서버에서 실행할 코드인지
구분할 수 있다.

클라이언트에 숨겨야 하는 코드는 `server` 디렉토리에 넣는다. 암호나 인증 
메커니즘 같은 코드를 `server` 디렉토리에 넣으면 된다.

`server` 디렉토리와 `public` 디렉토리 밖에 있는 CSS 파일도 하나로 합쳐진다.
클라이언트가 로드하는 것은 모두 합쳐진 번들 하나다.

쉽게 디버깅할 수 있도록 개발 모드에서는 JavaScript와 CSS 파일을 합치지 않는다.

Meteor 앱이 HTML 파일을 처리하는 방식은 다른 서버사이드 프레임워크와 다르다.
Meteor는 세 가지 최상위 엘리먼트를 모든 HTML 파일에서 검색한다. `<head>`,
`<body>`, `<template>`가 그 최상위 엘리먼트다. 페이지를 처음 로드할 때
Head는 Head끼리 Body는 Body끼리 하나로 취합해서 클라이언트로 전송한다.

앞의 다른 엘리먼트와는 달리 템플릿은 `Template` 네임스페이스의 JavaScript 
함수로 변환된다. 이 방식은 템플릿을 클라이언트로 보내기에 정말 편리한 
방식이다. 자세한 내용은 [templates](#templates)절에서 살펴보자.

Rails나 Django 프로젝트처럼 `public` 디렉토리에 있는 파일은 그대로 서비스된다.
이미지, `favicon.ico`, `robots.txt` 같은 파일은 이 디렉토리에 넣는다.

{{/better_markdown}}
</template>

<template name="data">
{{#better_markdown}}

<h2 id="data">Data</h2>

데이터가 필요할 때마다 RPC 통로를 뚫고, 서버를 거쳐야 하기 때문에 느려지고 
메시지를 제대로 보냈는지도 검사해야 했지만, Meteor에서는 그러지 않아도 
된다. Meteor는 로컬에서 데이터베이스로 접근하듯 사용할 수 있는 코드를 
클라이언트에 배포한다. 그리하여 클라이언트에서 바로 간단 명료하게 
데이터에 접근할 수 있다.

Meteor 클라이언트에는 in-memory 데이터베이스 캐시가 있다.
이 캐시에는 서버 데이터베이스의 도큐먼트 중 일부가 저장된다.
데이터베이스에서 도큐먼트가 변경되면 자동으로 도큐먼트를 이용하는
모든 클라이언트와 동기화된다.

클라이언트 캐시를 관리하려면 서버가 도큐먼트를 <b>Publish</b>하고
클라이언트가 <b>Subscribe</b>해야 한다. 채팅 시스템을 개발한다고 해보자.
서버는 모든 채팅방과 메시지를 Publish하고 클라이언트는 채팅방과
선택한 채팅방의 메시지를 Subscribe한다. 한번 Subscribe하면 클라이언트는
캐시를 로컬 데이터베이스처럼 사용한다. 클라이언트 모델 코드가 마법처럼 
단순해진다.

Meteor가 도큐먼트 업데이트를 퍼트리는 데(distributing) 사용하는 
프로토콜은 모든 데이터베이스를 지원한다(database agnostic). 기본적으로 
Meteor 앱은 <a target="_blank" 
href="http://www.mongodb.org/display/DOCS/Manual"> MongoDB API</a>를 
사용한다. 서버는 MongoDB 컬렉션에 도큐먼트를 저장하고 클라이언트는 
클라이언트 사이드에 도큐먼트를 캐시로 저장한다. 클라이언트는 데이터를 
검색하고 업데이트 하기 위한 캐시 API로 Mongo API를 그대로 구현했다.

    // 서버: 모든 채팅방 정보, 채팅방의 메시지를 Publish
    Meteor.publish("chatrooms");
    Meteor.publish("messages", function (room_id) {
      return Messages.find({room: room_id});
    });

    // 클라이언트: 모든 채팅방 정보, 첫 번째 채팅방의 메시지를 Subscribe
    Meteor.subscribe("chatrooms");
    Meteor.subscribe("messages", Chatrooms.find()[0]._id);

도큐먼트가 수정되면 자동으로 퍼진다. 클라이언트 캐시에서 `insert`,
`remote`, `update` 명령어로 문서를 수정하면 명령은 바로 실행된다. 동시에
클라이언트는 서버에 수정 명령을 전송하고 그러면 서버의 데이터베이스도 
변경된다. 물론 클라이언트와 서버가 데이터 변경에 동의하는 경우는 말이다.
클라이언트에서 수정한 내용을 서버가 거부할 수도 있다. 권한문제라던가
데이터를 동시에 다른 클라이언트도 수정할 때가 있을 수 있다.
서버는 데이터베이스를 수정하고 클라이언트에 도큐먼트를 다시 Publish한다.
Subscribe하는 클라이언트는 자동으로 그 문서를 받아서 업데이트한다.

    // 새 채팅 메시지는 클라이언트와 서버 모두에 반영된다.
    Messages.insert({room: 2413, text: "hello!"});

레이턴시 보정 기술을 사용하여 클라이언트는 항상 최신 데이터를 유지하며 
서버에 요청하고 응답할 때까지 절대 기다리지 않는다. 데이터를 수정해야 
하면 바로 로컬 캐시를 수정한다. 서버로부터 변경이 완료될 때까지 
기다리지 않는다. 다만, 서버 쪽 데이터도 변경되도록 수정 메시지를 
서버로 보낸다.

MongoDB 대신 다른 데이터베이스를 사용하고 싶다면 서버 데이터베이스
드라이버와 클라이언트 캐시를 만들어야 한다. `mongo-livedata` 패키지를
참고하여 만드는 것이 좋다.

{{/better_markdown}}
</template>

<template name="reactivity">
{{#better_markdown}}

<h2 id="reactivity">Reactivity</h2>

Meteor는 <a target="_blank" href="http://en.wikipedia.org/wiki/Reactive_programming">
Reactive 프로그래밍</a> 개념을 따른다. 이 말은 Imperative 프로그래밍
스타일로 코딩해도 데이터가 바뀌면 자동으로 다시 계산된다는 것을 의미한다.
(역주: `a = b + c`라는 수식이 있을 때 Imperative 프로그래밍에서는
b, c 값이 변경돼도 a 값이 변경되지 않는다. 하지만, Reactive 프로그래밍에서는
b, c 값이 변경되면 a 값도 바뀐다. - from wikipedia)

    Meteor.autosubscribe(function () {
      Meteor.subscribe("messages", Session.get("currentRoomId"));
    });

이것은 채팅 클라이언트 예제다. Subscribe해서 세션의 `currentRoomId`
값에 따라서 데이터를 받는다. `Session.get("currentRoomId")` 값이 변경되면
자동으로 함수를 실행해서 변경한 값으로 다시 Subscribe한다.

이 마법을 부리는 것은 `Session`과 `Meteor.autosubscribe`다.
`Meteor.autosubscribe` 메소드가 데이터 의존성을 추적하는
"Reactive 컨텍스트"를 만들고 필요할 때마다 아큐먼트로 넘겨받은
함수를 매번 실행한다. `Session` 같은 데이터 프로바이더는 무슨
데이터가 변경됐고 어떤 컨텍스트를 호출해야 하는지 알아내서
데이터가 변경됐다는 무효화(Invalidation) 시그널을 보낸다.

이 패턴이 적용되는 범위는 굉장히 넓다. 개발자가 Subscribe 관련 코드를
직접 작성하지 않아도 된다. Unsubscribe/Resubscribe를 호출하거나 이
함수들을 제때 호출되게 하는 일은 Meteor가 해준다. Meteor는 개발자가
데이터를 전파하는 코드를 작성할 필요가 없게 만들어 준다.

Reactive 컨텍스트를 만드는 Meteor 함수들:

* [`Meteor.render`](#meteor_render) and [`Meteor.renderList`](#meteor_renderlist)
* [`Meteor.autosubscribe`](#meteor_autosubscribe)
* [Templates](#templates)

변경됐음을 Trigger하는 Reactive 데이터 소스들:

* <a href="#session">Session</a> 변수
* <a href="#find">Collections</a>에 대한 데이터베이스 쿼리
* <a href="#meteor_status">`Meteor.status`</a>

메테오의 <a href="https://github.com/meteor/meteor/blob/master/packages/deps/deps.js" target="_blank">Reactive
구현</a>은 작지만 맵다. 겨우 50줄에 불과하다. 그 코드를 살펴보고
<a href="#meteor_deps">Meteor.deps</a> 모듈을 사용해서 데이터
소스나 Reactive 컨택스트를 직접 만들어 쓸 수 있다.

{{/better_markdown}}
</template>

<template name="livehtml">
{{#better_markdown}}

<h2 id="livehtml">Live HTML</h2>

웹 앱에서는 HTML 템플릿이 중요하다. Meteor의 라이브 페이지 업데이트
기술 덕택에 HTML을 _Reactive_하게 렌더링한다. 그래서 데이터가 수정되면
자동으로 HTML도 업데이트된다.

다른 HTML 템플릿 엔진을 사용할 수도 있고 JavaScript로 직접 생성할 수도
있다. 다음은 JavaScript로 생성하는 예다:

    var fragment = Meteor.render(
      function () {
        var name = Session.get("name") || "Anonymous";
        return "<div>Hello, " + name + "</div>";
      });
    document.body.appendChild(fragment);

    Session.set("name", "Bob"); // page updates automatically!

[`Meteor.render`](#meteor_render) 함수는 HTML 문자열을 반환하는
렌더링 함수를 아규먼트로 받는다. [`Meteor.render`](#meteor_render)는
자동으로 업데이트하는 `DocumentFragment`를 리턴한다. 렌더링 함수에서
사용하는 데이터가 변하면 다시 실행된다. `DocumentFragment`에 DOM 노드가
들어 있어 정확히 어디에 업데이트 해야 할지 알 수 있다. 페이지가 어떻게
업데이트되는지 걱정하지 않아도 된다. 모든 일이 자동으로 일어난다. 
[`Meteor.render`](#meteor_render)는 [Reactive 컨텍스트](#reactivity)를 
사용해서 렌더링 함수에서 사용하는 데이터가 무엇인지 알아낸다.

보통은 이 함수를 직접 호출하지 않는다. 그냥 Handlebar나 Jade처럼
선호하는 템플릿 패키지를 사용하면 된다. `render`나 `renderlist` 함수는 
템플릿 시스템을 새로 만들 때 필요하다.

Methor는 보통 업데이트를 하나로 모아서(Batch) 업데이트한다. 
배치 업데이트는 클라이언트 코드가 실행 중이지 않을 때 한다.
앱이 계속 실행 중이라면 DOM에 적용되지 않는다. 하지만, 바로 적용돼야
할 때도 있다. 데이터베이스에 레코드를 하나 추가하자마자 바로
DOM에도 적용되게 하려면 [`Meteor.flush`](#meteor_flush)를 호출한다.
DOM을 즉시 업데이트하면 jQuery 같은 라이브러리로 새로 추가된
엘리먼트에 접근할 수 있다.

라이브 DOM 엘리먼트가 화면에서 떨어지면 자동으로 정리된다.
관련 콜백도 파괴되고, 관련 데이터베이스 쿼리도 멈추고, 업데이트 중인
것도 멈춘다. 그래서 <a href="http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/" target="_blank">좀비 템플릿</a>
문제에 대해 걱정할 필요가 없다. 엘리먼트가 정리되지 않게
하려면 다음 이벤트 주기(event loop)가 오기 전이나
[`Meteor.flush`](#meteor_flush)를 호출하기 전에 다시 화면에 붙여야 한다(on-screen).

또 다른 문제로 '엘리먼트 상태 보존' 문제가 있을 수 있다.
사용자가 `<input>` 엘리먼트에 뭔가 입력하고 있을 때 페이지의
해당 부분이 다시 그려진다고 생각해보자. 그러면 포커스나 커서
위치가 계속 바뀌어서 사용자에게 울렁증이 올 수 있다. 그리고 `<input>`
엘리먼트가 다시 생성되면 부분적으로 입력한 텍스트나 관련
상태 정보를 잃게 된다.

Meteor는 이 문제도 해결해준다. 템플릿이 다시 렌더링될 때 템플릿에
[`preserve`](#template_preserve) 디렉티브를 명시하면 엘리먼트 상태가
보존된다. Meteor는 preserve 엘리먼트에 대해서 상위 템플릿이 다시 
렌더링될 때도 그 상태를 유지시킨다. 하지만 그 perserve 엘리먼트의 
자식 엘리먼트나 속성은 업되이트 된다.

{{/better_markdown}}
</template>

<template name="templates">
{{#better_markdown}}

<h2 id="templates">Templates</h2>

Meteor에서는 원하는 HTML 템플릿 엔진을 골라 사용하기 쉽다.
Handlebar도 Jade도 Meteor의 라이브 페이지 기술과 함께 사용할 수 있다.
다른 HTML 템플릿 엔진 패키지를 직접 만들어도 Meteor가 실시간으로
페이지를 업데이트한다.

이 기능을 사용하려면 `.html` 파일을 만든다. `.html` 파일을 만들고 
`<template>` 태그 추가한다. 이 태그의 `name` 속성에 템플릿 이름을 
입력한다. 그리고 이 `<template>` 태그 바디에 템플릿 내용을 넣는다. 
Meteor는 템플릿을 컴파일해서 클라이언트로 보낸다. 이 템플릿 함수는 
`Template` 객체를 통해 사용할 수 있다.

{{#note}}
현재 Meteor에 패키징 된 템플릿 엔진은 Handlerbars 뿐이다. Meteor에서
사용하고 싶은 템플릿 엔진이 있으면 알려 줘라. Handlerbar는
<a href="http://www.handlebarsjs.com/">Handlebars 문서</a>와
<a href="https://github.com/meteor/meteor/wiki/Handlebars">Meteor
Handlebars extensions</a>에서 자세히 설명한다.
{{/note}}

이름이 `hello`인 템플릿은 `Template.hello` 함수를 호출하여
렌더링한다. 템플릿 데이터는 호출할 때 넘긴다:

    <!-- in myapp.html -->
    <template name="hello">
      <div class="greeting">Hello there, {{dstache}}first}} {{dstache}}last}}!</div>
    </{{! }}template>

    // in the JavaScript console
    > Template.hello({first: "Alyssa", last: "Hacker"});
     => "<div class="greeting">Hello there, Alyssa Hacker!</div>"

템플릿 함수는 문자열을 반환하므로 [`Live HTML`](#livehtml) 시스템과
함께 사용할 수 있다. [`Meteor.render`](#meteor_render)에서
이 템플릿 함수를 사용하면 템플릿 데이터가 변경될 때 자동으로 업데이트된다:

    Meteor.render(function () {
      return Template.hello({first: "Alyssa", last: "Hacker"});
    })
      => automatically updating DOM elements

템플릿에서 사용할 데이터를 가장 쉽게 가져오는 방법은 JavaScript
helper 함수를 정의하는 것이다. `Template.[template name] 객체에
helper 함수를 바로 추가한다. 다음과 같은 템플릿이 있다고 하고:

    <template name="players">
      {{dstache}}#each top_scorers}}
        <div>{{dstache}}name}}</div>
      {{dstache}}/each}}
    </{{! }}template>

템플릿 함수를 호출할 때 `top_scorers`를 파라미터처럼 전달하지
않고 `Template.players`의 함수로 정의한다:

    Template.players.top_scorers = function () {
      return Users.find({score: {$gt: 100}}, {sort: {score: -1}});
    };

이렇게 함수로 정의한 `top_scorers` 데이터는 데이터베이스에서 가져온다.
쿼리에 대한 데이터베이스 커서는 `#each`로 전달되고, Meteor는 기계적으로
데이버베이스의 데이터를 DOM 노드로 추가하고 업데이트 하는 과정을 수행한다.

아규먼트가 있는 Helper 함수도 가능하다.
Helper 함수에서 `this`는 템플릿 데이터를 가리킨다:

    // JavaScript 파일
    Template.players.league_is = function (league) {
      return this.league === league;
    };

    <!-- HTML 파일 -->
    <template name="players">
      {{dstache}}#each top_scorers}}
        {{dstache}}#if league_is "junior"}}
          <div>Junior: {{dstache}}name}}</div>
        {{dstache}}/if}}
        {{dstache}}#if league_is "senior"}}
          <div>Senior: {{dstache}}name}}</div>
        {{dstache}}/if}}
      {{dstache}}/each}}
    </{{! }}template>

{{#note}}
`if`와 `league_is`는 기술적으로 헬퍼이고 기존의 Handlebar 로는
`league_is`를 실행하지 못한다. `{{dstache}}#if league_is "junior"}}`란
표현은 Meteor에서 Hanldebar를 확장한 것이다.
그 결과로 helper 블럭 안에서 helper를 사용할 수 있다.
{{/note}}

Helper 함수로 상수를 넘길 수 있다:

    // {{dstache}}#each sections}} 코드와도 잘 동작함
    Template.report.sections = ["Situation", "Complication", "Resolution"];

마지막으로 템플릿 함수의 `events` 프로퍼티로 이벤트 핸들러를 등록할
수 있다. 정확한 형식은 [Event Maps](#eventmaps)에 나와있다.
이벤트 핸들러의 `this`는 엘리먼트의 데이터 컨텍스트를 가리킨다.

    <!-- myapp.html -->
    <template name="scores">
      {{dstache}}#each player}}
        {{dstache}}> player_score}}
      {{dstache}}/each}}
    </{{! }}template>

    <template name="player_score">
      <div>{{dstache}}name}}: {{dstache}}score}}
        <span class="give_points">Give points</span>
      </div>
    </{{! }}template>

    <!-- myapp.js -->
    Template.player_score.events({
      'click .give_points': function () {
        Users.update({_id: this._id}, {$inc: {score: 2}});
      }
    });

지금까지 설명한 것을 복습해보자. 다음은 템플릿에 임의 데이터를
넣는 예제다. 데이터가 변경될 때마다 자동으로 업데이트한다.
자동으로 업데이트 하는 부분은 [Live HTML](#livehtml)에서 다룬다.

    <!-- in myapp.html -->
    <template name="forecast">
      <div>It'll be {{dstache}}prediction}} tonight</div>
    </{{! }}template>

    <!-- in myapp.js -->
    // JavaScript: reactive helper function
    Template.forecast.prediction = function () {
      return Session.get("weather");
    };

    <!-- in the console -->
    > Session.set("weather", "cloudy");
    > document.body.appendChild(Meteor.render(Template.forecast));
    In DOM:  <div>It'll be cloudy tonight</div>

    > Session.set("weather", "cool and dry");
    In DOM:  <div>It'll be cool and dry tonight</div>

{{/better_markdown}}
</template>

<template name="packages_concept">
{{#better_markdown}}

  <h2 id="smartpackages">Smart Packages</h2>

Meteor 패키징 시스템은 매우 강력하다.
지금까지 읽은 기능이 모두 표준 Meteor 패키지로 구현된다.

Meteor 패키지는 그 자체로도 JavaScript 프로그램이다.
그리고 클라이언트나 서버에 코드를 주입할 수도 있고 Bundler를 확장해서
필요한대로 확장할 수 있다. 다음과 같은 패키지를 보면:

* The <a href="#coffeescript">coffeescript</a> 패키지는 Bundler를 확장했다.
  <code>.coffee</code> 파일이 있으면 자동으로 컴파일한다.
  이 패키지를 추가하면 JavaScript가 아니라 CoffeeScript로도 개발할 수 있다.

* 클라이언트 라이브러리를 Meteor 패키지로 만들려면
  <a href="#jquery">jQuery</a>와 <a href="#backbone">Backbone</a> 패키지를
  참고하는 것이 좋다. 자바 스크립트 파일을 소스 트리에 복사해 넣어도
  되지만 패키지로 만드는 것이 더 빠르다.

* <a href="#underscore">underscore</a> 패키지는 클라이언트와 서버에
  모두 포함된다. Minimongo, Session 객체, Reactive Handlebar 등
  Meteor 핵심 패키지들은 자동으로 Meteor 앱에 포함된다.

<a href="#meteorlist">meteor list</a> 명령은 이용가능한 패키지를 보여준다.
<a href="#meteoradd">meteor add</a> 명령으로 프로젝트에 패키지를 추가하고
<a href="#meteorremove">meteor remove</a> 명령으로 제거할 수 있다.

패키지들에 대해서 <a href="#packages">Package 목록</a> 절에 간략하게
설명돼 있다.

{{#warning}}
패키지 API는 자주 변경되고 있고 아직 문서도 없으니 직접 패키지를 만들기는
쉽지 않다. 조만간 이 부분도 추가할 계획이다.
{{/warning}}

{{/better_markdown}}
</template>

<template name="deploying">
{{#better_markdown}}

<h2 id="deploying">Deploying</h2>

Meteor는 애플리케이션 서버다. 인터넷에 애플리케이션을 서비스하는 데 필요한
모든 것이 들어 있다. 개발자는 애플리케이션 코드(JavaScript, HTML, CSS)만 개발하면 된다.

<h3 class="nosection">Running on Meteor's infrastructure</h3>

<b>meteor deploy</b> 명령으로 사용하면 쉽게 앱을 배포할 수 있다.
meteor를 사용하면 새로운 아이디어를 구현하고, 매주 살을 붙이고,
그것을 세상에 공개하는 일을 가장 쉽게 할 수 있다.
나는 개인적으로 이런 게 필요하다고 생각해왔다.

    $ meteor deploy myapp.meteor.com

그러면 myapp.meteor.com에 앱이 배포된다. Meteor는 처음에 실행할 때
데이터베이스를 새로 만든다. 두 번째 실행할 때부터는 기존 데이터를
그대로 유지하고 단지 코드만 배포한다.

다른 도메인으로 배포할 수도 있다. 이때는 CNAME을
<code>origin.meteor.com</code>으로 설정하고 해당 hostname으로 배포한다.

    $ meteor deploy www.myapp.com

이것은 우리가 제공하는 무료 서비스로 Meteor를 돌려볼 수 있다.
내부 베타, 데모, 등등을 빨리 만들어 보는데 좋다.

<h3 class="nosection">Running on your own infrastructure</h3>

Heroku 같은 호스팅 업체 같은 곳에도 자유롭게 배포할 수 있다.

다음과 같이 실행한다.

    $ meteor bundle myapp.tgz

이 명령어는 Node.js 애플리케이션을 tar 파일로 떨어뜨려 준다. 이 앱을 실행하는
데는 Node.js 0.6과 MongoDB 서버가 필요하다. MongoDB URL과 HTTP 포트를
명시하고 애플리케이션을 실행한다.
가진 MongoDB가 잆으면 [MongoHQ](http://mongohq.com)를 사용하면 좋다.

    $ PORT=3000 MONGO_URL=mongodb://localhost:27017/myapp node bundle/main.js

{{#warning}}
지금까지 번들은 해당 번들을 만든 플랫폼에서만 실행했다. 다른 플랫폼에서
실행하려면 번들에 있는 네이티브 패키지를 다시 빌드해야 한다.
<code>npm</code>을 사용해서 다음과 같이 실행한다:

    $ cd bundle/server/node_modules
    $ rm -r fibers
    $ npm install fibers@0.6.5
{{/warning}}

{{/better_markdown}}
</template>
