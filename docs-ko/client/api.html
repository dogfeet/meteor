<template name="api">
{{#better_markdown}}

<h1 id="api">The Meteor API</h1>

Javascript 코드는 *서버*와 *클라이언트* 모두에서 실행된다.
클라이언트는 브라우저이고 서버는 [Node.js](http://nodejs.org/)컨테이너이다.
이 API 레퍼런스에서는 함수를 설명할 때 그 함수가 클라이언트용인지 서버용인지 명시한다.

<h2 id="core"><span>Meteor Core</span></h2>

{{> api_box isClient}}
{{> api_box isServer}}
{{> api_box startup}}

클라이언트에서는 DOM ready 상태가 되고 `.html` 파일에 정의한 `<body>`
템플릿이 화면에 다 그려지고 나면 이 함수가 실행된다.

    // DB의 내용이 빈 채로 서버가 시작되면 초기 데이터를 생성
    if (Meteor.isServer) {
      Meteor.startup(function () {
        if (Rooms.find().count() === 0) {
          Rooms.insert({name: "Initial room"});
        }
      });
    }

{{> api_box absoluteUrl}}

<h2 id="publishandsubscribe"><span>Publish와 subscribe</span></h2>

Meteor 서버가 어떻게 레코드를 Publish하고 또 어떻게 그 레코드를 Subscribe해야
하는지 설명한다. 여기서 설명하는 함수로 Publish와 Subscribe를 제어한다.

{{> api_box publish}}

서버에서 `Meteor.publish`를 호출하면 클라이언트에 Publish할 수 있다.
Publish 할 레코드 셋 이름과 클라이언트가 Subscribe를 할 때마다 호출될
*Publish 함수*, 이렇게 아규먼트를 두 개 주고 호출한다.

Meteor에서 커서 Document를 Publish하려면 Publish 함수에서
[`Collection.Cursor`](#meteor_collection_cursor) 타입 객체를 리턴하면 된다.

    // server: secretInfo 컬럼을 제외한 rooms Collection을 Publish한다.
    Meteor.publish("rooms", function () {
      return Rooms.find({}, {fields: {secretInfo: 0}});
    });

    // ... 그리고 아래 코드는 로그인 된 유저가 admin이면 secret info를
    // publish한다. 만약 클라이언트가 두 스트림을 subscribe하고 있다면 
    // Room 컬렉션의 같은 도큐먼트로 머지된다.
    Meteor.publish("adminSecretInfo", function () {
      return Rooms.find({admin: this.userId}, {fields: {secretInfo: 1}});
    });

그리 Publish 함수에서 레코드의 어트리뷰트를 추가, 삭제할 수 있다.
Publish 함수에서 `this`의 [`set`](#publish_set), [`unset`](#publish_unset) 메소드를 호출해서 추가, 삭제한다.

<!-- discuss complete -->

[`observe`](#observe)를 사용해서 DB가 변경되는 것을 지켜보려면
observe 콜백 안에서 `this.flush`를 호출해 줘야 한다.
DB를 업데이트하는 메소드는 observe에 넘긴 콜백에서 리턴하면
업데이트 작업이 완료됐다고 간주한다.

예제:

    // server: publish the current size of a collection
    Meteor.publish("counts-by-room", function (roomId) {
      var self = this;
      var uuid = Meteor.uuid();
      var count = 0;

      var handle = Messages.find({roomId: roomId}).observe({
        added: function (doc, idx) {
          count++;
          self.set("counts", uuid, {roomId: roomId, count: count});
          self.flush();
        },
        removed: function (doc, idx) {
          count--;
          self.set("counts", uuid, {roomId: roomId, count: count});
          self.flush();
        }
        // don't care about moved or changed
      });

      // remove data and turn off observe when client unsubs
      self.onStop(function () {
        handle.stop();
        self.unset("counts", uuid, ["roomId", "count"]);
        self.flush();
      });
    });

    // client: declare collection to hold count object
    Counts = new Meteor.Collection("counts");

    // client: autosubscribe to the count for the current room
    Meteor.autosubscribe(function () {
      Meteor.subscribe("counts-by-room", Session.get("roomId"));
    });

    // client: use the new collection
    console.log("Current room has " + Counts.findOne().count + " messages.");

{{#warning}}
`autopublish` 패키지를 사용한 프로젝트에서 `Meteor.publish`를 호출하면
현재 Publish 중이라는 경고 메시지를 보여주지만, Publish는 정상적으로 동작한다.
{{/warning}}


{{> api_box subscription_userId}}

이것은 상수이다. 하지만 로그인 유저가 바뀐다면 publish 함수는 새로운 값을 
리턴해준다.

{{> api_box subscription_set}}
{{> api_box subscription_unset}}
{{> api_box subscription_complete}}
{{> api_box subscription_flush}}

{{> api_box subscription_onStop}}

Publish 핸들러에서 [`observe`](#observe)를 호출했으면 그 핸들러 안에서 멈춰야 한다.

{{> api_box subscription_stop}}

{{> api_box subscribe}}

Subscribe하는 것은 레코드를 클라이언트로 보내달라고 서버에 알리는 것이다.
클라이언트는 이 레코드를 로컬에 있는 Minimongo의 컬렉션에 저장한다. 이 때
컬렉션 이름이 같아야 한다. Meteor는 해당 이름으로 된 `Meteor.Collection`이
만들어질 때까지 들어오는 데이터를 큐에 넣는다.

    // okay to subscribe (and possibly receive data) before declaring
    // the client collection that will hold it.  assume "allplayers"
    // publishes data from server's "players" collection.
    Meteor.subscribe("allplayers");
    ...
    // client queues incoming players records until ...
    ...
    Players = new Meteor.Collection("players");

여러 개의 Subscription에서 동일한 속성에 대해 서로 다른 값을 보내오면 첫 번째로 설정한 Subscription의 값을 사용한다. 해당 값이 먼저 도착한 값이 아니라고 해도 첫 번째 Subscription의 값을 사용한다.

Document의 속성이 모두 삭제되면 Document도 삭제된다.
빈 Document를 Publish하고 싶으면 아무 속성이나 하나 넣어야 한다.

    Clicks.insert({exists: true});

{{> api_box autosubscribe}}

`func`는 넘기는 즉시 실행되고 레코드에 대해서 Subscribe한 것은 계속 유지된다.
[`Meteor.subscribe`](#meteor_subscribe)으로 Subscribe하고
[`Session.get`](#session_get)과 [`collection.find`](#find)를 호출해서
데이터를 가져온다.

데이터가 변경될 때마다 Subscribe한 것은 취소하고 `func`를 다시 실행해서
다시 Subscribe해야 한다. `Meteor.autosubscribe`는 기존의 Subscribe한 것을
자동으로 중단한다. 그래서 `Meteor.autosubscribe` 안에서는 수동으로
Subscribe를 중단하지 않아도 된다.

예제:

    // Subscribe to the chat messages in the current room. Automatically
    // update the subscription whenever the current room changes.
    Meteor.autosubscribe(function () {
      Meteor.subscribe("chat", {room: Session.get("current-room");});
    });

<h2 id="methods_header"><span>Methods</span></h2>

Method는 Meteor 클라이언트가 실행하는 원격 함수다.

{{> api_box methods}}

예제:

    Meteor.methods({
      foo: function (arg1, arg2) {
        // .. do stuff ..
        if (you want to throw an error)
          throw new Meteor.Error(404, "Can't find my pants");
        return "some return value";
      },

      bar: function () {
        // .. do other stuff ..
        return "baz";
      }
    });

서버에서 `methods` 함수를 호출해서 클라이언트 클라이언트가 원격에서 실행할 수 있는 함수를 정의한다. 여기서 정의하는 함수는 값을 리턴하고 예외를 던질 수 있다. `this`는 메소드를 실행하는 객채를 가리키고 그 객체에는 다음과 같은 게 들어 있다:

* `isSimulation`: Boolean 값, stub 함수일 때 true
* `unblock`: 이 함수를 호출하면 다음 Method는 해당 Method가 
끝날 때까지 블럭하지 않는다. 다음 Method는 다른 Fiber에서 실행된다.
* `userId`: 현재 유저의 아이디.
* `setUserId`: 현재 클라이언트를 해당 유저와 연결시키는 함수.

클라이언트에서 `methods`를 호출하면 서버의 메소드와 이름이 같은 *stub* 함수가 정의된다.
stub 함수는 필요할 때만 정의해서 사용할 수 있다. stub 함수가 있을 때 원격 메소드를 
호출하면 서버 결과를 기다리지 않는다.

stub을 정의하면 클라이언트가 서버 Method를 실행할 때 stub 함수도 병렬로 실행된다.
클라이언트에서는 stub이 리턴하는 값은 무시된다. stub은 서버 메소드의 결과를
*흉내(simulate)*내는 것뿐이고 서버를 거치지 않기 때문에 지연도 없다.
Stub이 예외를 던지면 console에 로그가 출력된다.

{{> api_box method_invocation_userId}}

유저의 id는 임의의 스트링으로 보통 데이터베이스에 있는 유저 레코드의 아이디를 사용한다.
`setUserId` 함수를 이용해 이를 설정할 수 있다. 
[Meteor accounts system](#accounts_api)를 이용해서 쉽게 관리할 수 있다.

{{> api_box method_invocation_setUserId}}

이 메서드로 현재 접속해 있는 사람이 로그인 한 유저를 다른 유저로 바꿀 수 있다.
현재 커넥션에서 앞으로 호출하는 메서드들은 `userId`의 값을 사용하는데, 이 
메서드는 단순히 그 값을 재할당하는 함수이다. `null`을 넘기는 것으로 로그아웃한다.

[내장된 Meteor accounts system](#accounts_api)을 사용한다면 이 시스템은 
[`Meteor.users`](#meteor_users)콜렉션에 있는 한 도큐먼트의 `_id`필드와 
userId를 같게 취급할 것이다.

`setUserId`는 기존 시스템에 소급적용되지 않는다. 다시 말해 이 메서드는 지금부터 
호출될 메서드들에만 적용된다. 현재 커넥션에서 `setUserId`호출 이전의 메서드들은
그 메서드 호출을 시작했을 당시의 `userId`를 가지고 실행된다.

{{> api_box method_invocation_isSimulation}}

{{> api_box method_invocation_unblock}}

서버에서, 클라이언트가 원격 메소드를 동시에 호출해도 서버에서는 한 번에 하나씩 호출된다.
N+1번째 실행한 메소드는 N 번째 실행이 끝날 때까지 시작하지 않는다. 하지만 `this.unblock`을 호출하면 바꿀 수 있다. 이 함수를 호출하면 N+1번째 메소드는 다른 Fiber에서 실행된다.

{{> api_box error}}

Method는 예외를 던져서 에러를 리턴한다. 클라이언트에 전송되는 에러는
`Meteor.Error`뿐이다. 다른 예외를 던지면 `Meteor.Error(500, "Internal server error")`가
클라이언트에 전송된다.

{{> api_box meteor_call}}

이 함수로 서버 Method를 실행한다. 그리고 클라이언트에 해당 Stub이 있으면 Stub도 실행된다.

마지막 아규먼트로 콜백 함수를 넘기면 비동기로 호출된다(함수는 Serializeable하지
않기 때문에 원격에 전송할 수 없다). 비동기로 호출하면 아무것도 리턴하지 않고 예외를
던지지도 않는다. Method가 완료되면 콜백이 호출되는데 이때 `error`와 `result`가
아규먼트로 넘어온다. 에러가 있으면 `error`는 예외 객체가 넘어오고 에러가
없으면 `error`는 undefined가 되고 `result`에 결과가 리턴된다.

    // async call
    Meteor.call('foo', 1, 2, function (error, result) { ... } );

콜백을 넘기지 않으면 해당 Method가 완료될 때까지 블럭된다. 이 메소드는 서버의
Method가 리턴한 값을 리턴하거나 서버가 던진 예외를 그대로 던진다. 서버 Method가
명시적으로 `Meteor.Error`를 던진 게 아니면 500 서버 에러를 던진다.

    // sync call
    var result = Meteor.call('foo', 1, 2);

클라이언트에서는 `call` 함수를 호출하면 다르게 동작한다. 클라이언트에서는
콜백 없이 `call` 함수를 실행하면 `undefined`가 리턴된다. 클라이언트에는 
Fibers가 없어서 서버 Method가 리턴할 때까지 블럭 시킬 방법이 없다.
그리고 Stub 함수 안에서 `call` 함수를 사용할 수 없다. 
서버 Method가 리턴하는 값을 리턴하게 할 수 없다.

마지막으로 Stub 함수 안에서는 다른 Method를 호출해도 실행되지 않는다. Stub은 RPC도 아니고
가짜라서 Method를 호출할 필요가 없다. 하지만, Method에서는 Stub을 호출할 수 있다. `call`
함수는 Stub 함수가 리턴하는 값을 리턴한다. 클라이언트에서 `Meteor.call`을 동기로 호출할 수
없다고 했는데 Stub Method는 괜찮다. Stub은 즉시 결과를 리턴한다.

DB 수정 함수는(`insert`, `update`, `remove`) Method로 구현했기 때문에 우리는 항상 이
기능을 사용하게 된다. 클라이언트에서 DB 함수를 호출하면 Stub 버전이 실행돼서
클라이언트 로컬 캐시가 수정된다. 어떤 함수에서 호출하든 최상위에서 호출하든 호출하는 위치는
상관없다. 서버 DB를 수정하는 실제 버전을 수정하지 않고 계정이나 권한 같은
정보는(credentials) 서버에서만 사용할 수 있다.

{{> api_box meteor_apply}}

`Meteor.apply`는 `Meteor.call`과 비슷하지만 아규먼트를 배열에 담아서 넘길 수 있다.
그리고 클라이언트의 메서드를 호출 방식을 옵션으로 지정할 수도 있다.

<h2 id="connections"><span>Server connections</span></h2>

이 함수는 Meteor 클라이언트와 서버 간의 네트워크 연결을 살펴보고 관리하는 데 사용한다.

{{> api_box status}}

이 메소드는 클라이언트와 서버 간의 연결 상태를 리턴한다. 리턴 객체에는 다음과 같은 필드가 있다:

<dl class="objdesc">
<dt><span class="name">connected</span>
  <span class="type">Boolean</span></dt>
<dd>서버에 연결돼 있으면 True다. 연결이 끊기면 다시 연결될 때까지 모든 변경 내역과
  메소드 실행은 큐에 담긴다.</dd>

<dt><span class="name">status</span>
  <span class="type">String</span></dt>
<dd>연결을 시도하는 상태를 나타낸다. 연결이 확립된 상태면 `connected`, 연결을
  시도하고 있으면 `connecting`, 연결에 실패해서 기다리는 상태면
  `waiting`이다.</dd>

<dt><span class="name">retryCount</span>
  <span class="type">Number</span></dt>
<dd>연결을 시도한 횟수. 0이면 연결된 거다.</dd>

<dt><span class="name">retryTime</span>
  <span class="type">Number or undefined</span></dt>
<dd>다음에 다시 연결을 시도하는 시간. 재연결 간격을 알고 싶으면
  `retryTime - (new Date()).getTime()`라고 실행한다.
  `status`가 `waiting`일 때만 이 프로퍼티가 설정된다.</dd>

</dl>

이것은 [Reactive](#reactivity) 데이터 소스이기 때문에 콜백을 사용할 필요가 없다.
[템플릿](#templates)이나 [invalidation](#meteor_deps)에서
사용하면 업데이트가 실시간으로 잘 된다.

{{> api_box reconnect}}

{{> api_box connect}}

다른 Meteor 앱의 Method를 호출하거나 데이터를 Subscribe하려면 그 앱의 URL을 주고
`Meteor.connect`를 호출한다. `Meteor.connect`는 다음과 같은 메소드가 있는 객체를 리턴한다:

* `subscribe` -
  레코드 셋을 subscribe한다. [Meteor.subscribe](#meteor_subscribe)를 참고하라.
* `call` -
  메서드를 호출한다. [Meteor.call](#meteor_call)를 참고하라.
* `apply` -
  아규먼트를 배열로 받아 메서드를 호출한다. [Meteor.apply](#meteor_apply)를 참고하라.
* `methods` -
  리모트 서버에 정의된 메서드와 매핑되는 클라이언트 만의 stub를 정의한다.
  [Meteor.methods](#meteor_methods)를 참고하라.
* `status` -
  현재 커넥션의 상태를 가져온다. [Meteor.status](#meteor_status)를 참고하라.
* `reconnect` -
  [Meteor.reconnect](#meteor_reconnect)를 참고하라.
* `onReconnect` - 재접속을 시작할 때 가장 처음으로 불릴 함수를 설정한다. 이 함수는 
  다른 어떤 함수보다도 먼저 실행된다. 예를 들어 다시 연결을 맺을때 새 연결에 적합한
  인증 컨텍스트를 사용하도록 할 수 있다.

기본적으로 클라이언트 로드가 완료되면 커넥션을 시작한다.
`Meteor.subscribe`, `Meteor.status`, `Meteor.call`, `Meteor.apply`를 직접 호출하면
기본 서버에 연결된다.

{{#warning}}
이번 버전에서는 아직 클라이언트에서만 `Meteor.connect`를 사용할 수 있다.
아직 서버에서 다른 서버로 접속할 수 없다.
{{/warning}}

<h2 id="collections"><span>Collections</span></h2>

Meteor는 데이터를 *컬렉션*에 저장한다. `new Meteor.Collection`으로 컬렉션을 정의한다.

{{> api_box meteor_collection}}

이 함수는 ORM(Object-Relation Mapper)에서 모델을 정의하는 것과 비슷하게 호출한다.
사용자, 글, 점수, todo 아이템 같은 정보를 저장하는 *컬렉션*을 만든다.
사실 아무 데이터나 다 저장할 수 있다. 도큐먼트는 JSON 객체이고 `Id` 프로퍼티가 있어서
그 값으로 컬렉션에서 해당 도큐먼트를 식별한다.
Meteor는 도큐먼트를 만들 때 이 `Id` 값을 생성한다.

    // common code on client and server declares livedata-managed mongo
    // collection.
    Chatrooms = new Meteor.Collection("chatrooms");
    Messages = new Meteor.Collection("messages");

`Meteor.Collection`이 리턴하는 객체에는 
도큐먼트를 컬렉션에 입력하는 [`insert`](#insert), 
도큐먼트 프로퍼티를 수정하는 [`update`](#update), 
도큐먼트를 삭제하는 [`remove`](#remove), 
도큐먼트를 검색하는 [`find`](#find)가 있다. 
메소드는 유명한 Mongo API와 비슷하게 동작하며 클라이언트와 서버에서 모두 사용할 수 있다.

    // return array of my messages
    var myMessages = Messages.find({userId:Session.get('myUserId')}).fetch();

    // create a new message
    Messages.insert({text: "Hello, world!"});

    // mark my first message as "important"
    Messages.update(myMessages[0].id, {$set: {important: true}});

`name`을 주고 컬렉션을 만들면 Persistent 컬렉션이 정의된다. 서버에 저장되기 때문에
모든 사용자가 볼 수 있다. 클라이언트와 서버 코드는 동일한 API로 컬렉션에 접근한다.

정확히 말해서 `name`을 주고 컬렉션을 만들면 다음과 같은 일들이 일어난다:

* 서버에서는 백엔드 Mongo 서버에 주어진 이름으로 컬렉션이 만들어진다.
  서버 컬렉션의 메소드를 호출하면 (사용자의 [접근 제어 규칙](#allow)를 체크한 후에)
  Mongo 오퍼레이션으로 바로 변환된다. 

* 클라이언트에서는 Minimongo 인스턴스가 만들어진다. Minimongo는 in-memory이고,
  non-persistent 이면서, 순수하게 JavaScript로 만들어진 Mongo 구현체이다. Minimongo는
  DB에 있는 데이터 중에서 클라이언트에 필요한 것만 저장하는 로컬 캐시로 사용한다.
  클라이언트에서 실행하는 [`find`](#find) 쿼리는 서버와 통신하지 않고 캐시에서만 찾는다.

* 클라이언트에서 DB 쓰기 명령을 실행하면 
  ([`insert`](#insert), [`update`](#update), [`remove`](#remove)) 클라이언트에서는 바로
  적용되고 서버에도 전송돼서 DB에 써진다.
  이 쓰기 명령이 실행되면 `livedata` 패키지에 할 일이 생긴다.

컬렉션 이름을 `null`로 주면 로컬 컬렉션을 생성한 것이고 서버와 동기화하지 않는다.
이 컬렉션은 일종의 연습장이라서 Mongo 스타일의 [`find`](#find), [`insert`](#insert),
[`update`](#update), [`remove`](#remove) 명령어를 맘껏 사용할 수 있다.
Minimongo가 제공하는 이 연습장은 클라이언트에서도 사용할 수 있지만, 서버에서도 사용할 수 있다.

Meteor는 자동으로 컬렉션에 있는 모든 도큐먼트를 모든 클라이언트에 Publish한다.
이 기능을 끄려면 다음과 같이 `autopublish` 패키지를 제거한다.

    $ meteor remove autopublish

그리고 그 대신 특정한 유저를 지정해서 특정 콜렉션을 [`Meteor.publish`](#meteor_publish)로
publish한다.

    // Create a collection called Posts and put a document in it. The
    // document will be immediately visible in the local copy of the
    // collection. It will be written to the server-side database
    // a fraction of a second later, and a fraction of a second
    // after that, it will be synchronized down to any other clients
    // that are subscribed to a query that includes it (see
    // Meteor.subscribe and autopublish)
    Posts = new Meteor.Collection("posts");
    Posts.insert({title: "Hello world", body: "First post"});

    // Changes are visible immediately -- no waiting for a round trip to
    // the server.
    assert(Posts.find().count() === 1);

    // Create a temporary, local collection. It works just any other
    // collection, but it doesn't send changes to the server, and it
    // can't receive any data from subscriptions.
    Scratchpad = new Meteor.Collection;
    for (var i = 0; i < 10; i++)
      Scratchpad.insert({number: i * 2});
    assert(Scratchpad.find({number: {$lt: 9}}).count() === 5);

{{#warning}}

이번 버전의 Minimongo는 몇 가지 부족한 부분이 있다:

* 셀렉터에 `$elemMatch`가 지원되지 않는다.
* `$pull` Modifier는 특정 셀렉터에만 사용할 수 있다.
* 셀렉터에서 닷(.) 노테이션과 인덱스가 제대로 동작하지 않는다.
* 서브키에 대한 정렬을 지원하지 않는다. `a`에 대해서는 가능하지만 `a.b`는 지원하지 않는다.
* `findAndModify`, upsert, aggregate 함수, map/reduce는 지원하지 않는다.
* 형식은 String, Number, Boolean, Array, Object만 지원한다.

여기서 언급한 것은 앞으로 뭔가 조치가 있을 것이다. 저장소에 있는 
packages/minimongo/NOTES 파일이 Minimongo 릴리즈 노트이며 자세한 내용은 이 파일을 확인하자.
{{/warning}}

{{#warning}}
Minimongo는 현재 index가 없다. 하지만, 곧 구현할 것이다. 클라이언트에는 데이터가 많지
않아서 보통 이슈가 안된다. 어쨌든 클라이언트에서 index가 필요한 일은 드물다.
{{/warning}}

{{> api_box find}}

`find`는 커서를 리턴한다. 커서는 DB에 접근하는 것도 아니고 실제 도큐먼트가
들어 있지도 않다. 커서는 조건에 만족하는 도큐먼트를 `fetch`하거나, `iterate`하거나,
`map`하거나, `forEach`하거나, 콜백을 등록해서 `observe`하는 기능을 제공한다.

{{#warning}}
컬렉션 커서는 질의하는 순간의 스냅샷이 아니다. 커서는 데이터를 가져오는 순간의 스냅샷을
가져오고 그 사이에 DB가 변경되면 변경내용이 포함될 수도 있고 포함되지 않을
수도 있다. `Collection.find`를 호출하고 나서 커서를 만드는 사이에, 그리고 그 커서로
데이터를 가져오는 사이에 DB가 변하면 변한대로 가져온다.
{{/warning}}

커서는 Reactive 데이터 소스다. Reactive 컨텍스트에서(eg, 
[`Meteor.render`](#meteor_render)또는 [`Meteor.autosubscribe`](#meteor_autosubscribe))
커서의 `fetch`, `map`, `forEach` 메소드로 도큐먼트를 가져오면 Meteor는 데이터 의존성을
등록한다. 커서에 있는 도큐먼트가 수정되면 무효화 돼서 다시 렌더링된다.
find에 `{reactive: false}` 옵션을 주고 이 동작을 끌 수 있다.

{{> api_box findone}}

`find(selector, options).fetch()[0]`와 똑같다.

{{> api_box insert}}

컬렉션에 도큐먼트를 추가한다. 이 도큐먼트는 객체이고 각 필드에 JSON 호환 데이터
타입을 할당할 수 있다. JSON 호환 데이터 타입은 '배열, 객체, 숫자, 스트링, null,
true, false'를 말한다.

`insert`는 객체에 필요한 ID를 생성한다. 그리고 DB에 객체를 넣고서 그 ID를 리턴한다.

서버에서는 콜백 없이 `insert`를 실행하면 블럭되며 DB에서 쓰기가 끝났다고
알려주거나 뭔가 문제가 있어서 예외가 발생하면 풀린다. 콜백을 주고 `insert`를 실행하면
즉시 ID를 리턴한다. insert가 성공했든 실패했던지 간에 콜백으로 `error`, `result`
아규먼트를 넘긴다. 에러가 있으면 `result`에는 undefined를 넘긴다.
성공하면 `error`에 undefined를 넘기고 `result`에는 도큐먼트 ID를 넘긴다.

클라이언트에서, `insert`는 블럭되지 않는다. 콜백 없이 insert를 호출했는데 서버에서
실패하면 Meteor는 그냥 콘솔에 로그를 남긴다. 콜백을 주고 호출하면 Meteor는 콜백으로
`error`, `result` 아규먼트를 넘긴다. 에러가 있으면 `result`는 undefined를 넘기고 성공하면 `error`는 undefined이고 `result`는 도큐먼트 ID를 넘긴다.

예제:

    var groceriesId = Lists.insert({name: "Groceries"});
    Items.insert({list: groceriesId, name: "Watercress"});
    Items.insert({list: groceriesId, name: "Persimmons"});

{{> api_box update}}

`selector` 조건에 일치하는 도큐먼트를 찾아서 `modifier`로 수정한다([modifier documentation](#modifiers)). 기본적으로 일치하는 도큐먼트를 수정하는 것이고 `multi`가 true면 일치하는 도큐먼트를 전부 수정한다.

selector 말고 스트링을 넘길 수도 있는데, 넘긴 스트링은 `Id`의 값으로 간주한다.

서버에서는 `update`를 콜백 없이 호출하면 DB가 보낸 ACK를 받거나 예외가 던져질 때까지 블럭된다. 콜백을 주면 `update`는 즉시 리턴하고 작업이 완료되면 아규먼트 없이 콜백이 호출되고 에러가 있으면 `error` 아규먼트가 넘어온다.

클라이언트에서는 `update`가 절대 블럭하지 않는다. 콜백 없이 호출했는데 update가 서버에서 실패하면 Meteor는 console에 로그를 남긴다. 콜백을 주고 호출하면 Mereor는 에러가 있을 때 `error` 아규먼트를 넘기면서 콜백을 호출하고 에러가 없으면 아규먼트 없이 호출한다.

예제:

    // Give the "Superlative" badge to each user with a score greater than
    // 10. If they are logged in and their badge list is visible on the
    // screen, it will update automatically as they watch.
    Users.update({score: {$gt: 10}},
                 {$addToSet: {badges: "Superlative"}},
                 {multi: true});

{{#warning}}
Mongo의 `upsert` 기능은 구현하지 않았다.
{{/warning}}

{{> api_box remove}}

`selector`에 만족하는 도큐먼트를 모두 찾아서 삭제한다. selector 대신 스트링을 넣으면
스트링이 `Id`인 도큐먼트를 삭제한다. selector가 undefined이면 위험해서 아무것도
하지 않는다. 대신 selector가 `{}`이면 모든 도큐먼트를 삭제한다.

서버에서는 콜백 없이 `remove`를 호출하면 DB가 ACK를 주거나 예외가
날 때까지 블럭한다. 콜백을 주고 호출하면 `remove`는 바로 리턴한다. remove가 완료되면
콜백이 호출될 때 에러가 있으면 error가 아규먼트로 넘어오고 에러가 없으면
아규먼트 없이 호출한다.

클라이언트에서는 `remove`를 절대 블럭하지 않는다. 콜백 없이 호출했는데
remove메소드가 서버에서 실패하면 Meteor는 console에 로그를 남긴다. 콜백을 주고
호출하면 Mereor는 에러가 있을 때 `error` 아규먼트를 넘기면서 콜백을 호출하고
에러가 없으면 아규먼트 없이 호출한다.

예제:

    // Delete all users with a karma of less than -2.
    Users.remove({karma: {$lt: -2}});

    // Delete all the log entries
    Logs.remove({});

{{> api_box allow}}

클라이언트가 collection의 `insert`나 `update`, `remove`메서드를 호출했을 때
콜렉션의 `allow`와 [`deny`](#deny) 콜백이 서버에서 호출된다. 이 콜백은 쓰기 행위가
허용되었는지 확인하는 작업을 한다. 만약 적어도 하나의 `allow`라도 쓰기를 허용하고
`deny`들 중 아무런 콜백도 쓰기를 금지하지 않으면 최종적으로 쓰기가 허락된다.

이벤트 핸들러에서 `update`를 호출할 때처럼 클라이언트에서 데이터베이스에 
직접적으로 쓰기 연산을 할 때에만 이런 체크를 수행한다. 서버의 코드는 신뢰성있다.
따라서 `allow`나 `deny` 제한에 종속적이지 않다. 그러한 메서드에는 `Meteor.call`도 
포함된다. 이 메서드는 `allow`나 `deny`가 아닌 스스로 접근 권한을 체크하는 것을 권장한다.

`allow`는 원하는 만큼 여러번 호출할 수 있으며 호출 할 때 마다 
`insert`, `update`, `remove` 메서드의 다양한 조합을 사용할 수 있다. 
연산이 허용된다면 `true`를 리턴해야 한다. 그렇지 않다면 `false`나 
아무것도 아닌 값(`undefined`)을 리턴한다. 이런 경우 Meteor는 콜렉션에 걸려있는
다른 `allow`함수를 찾아 수행한다.

사용 가능한 콜백은 다음과 같다.

<dl class="callbacks">
{{#dtdd "insert(userId, doc)"}}
`userId`의 유저가 도큐먼트 `doc`을 콜렉션에 추가하려한다.
허용한다면 `true`를 리턴한다.
{{/dtdd}}

{{#dtdd "update(userId, docs, fields, modifier)"}}
The user `userId` wants to update some documents. Meteor has fetched the
`userId`의 유저가 여러개의 도큐먼트를 업데이트 하려한다. Meteor는 데이터베이스에서
도큐먼트를 가져와서 `docs`변수에 넣는다. 이 도큐먼트의 수정을 허용한다면 `true`를
리턴한다.

수정할 사항에 대한 추가 정보는 `fields`와 `modifiers`에 들어있다. 
`fields`는 클라이언트가 수정하고자 하는 도큐먼트의 최상위 레벨 필드들이다.
예를 들자면 `['name', 'score']`같은 것들이다.
`modifier`는 클라이언트에서 실행하려는 raw Mongo modifier이다. 예를 들자면
`{$set: {'name.first': "Alice"}, $inc: {score: 1}}`같은 것들이다.

`$set`이나 `$push`연산 같은 Mongo modifier만 지원한다. 사용자가 
$-modifier를 사용하지 않고 도큐먼트를 수정하려 한다면 `allow`로 체크할 
필요도 없이 수정은 취소된다.

{{/dtdd}}

{{#dtdd "remove(userId, docs)"}}
`userId`를 가진 유저는 어떤 도큐먼트를 지우려한다. Meteor는 
데이터베이스에서 도큐먼트를 가져와서 `docs`에 배열 형태로 넘겨준다. 
해당 유저가 아규먼트로 들어온 도큐먼트를 지우는것을 허락하려면 `true`를 리턴한다.
{{/dtdd}}

</dl>

아무것도 명시하지 않으면 Meteor가 `docs` 배열을 만들 목적으로 데이터베이스에서 
도큐먼트를 가져올 때, 기본적으로 그 도큐먼트의 모든 필드를 검색한다. 효율성을 위해서 함수를 이용해 딱 
필요한 필드 만을 검색할수도 있다. `fetch`옵션을 이용하면 된다. 필요한 필드 이름을 배열로 만들면 된다.

예제:

    // Create a collection where users can only modify documents that
    // they own. Ownership is tracked by an 'owner' field on each
    // document. All documents must be owned by the user that created
    // them and ownership can't be changed. Only a document's owner
    // is allowed to delete it, and the 'locked' attribute can be
    // set on a document to prevent its accidental deletion.

    Posts = new Meteor.Collection("posts");

    Posts.allow({
      insert: function (userId, doc) {
        // 유저는 반드시 로그인되어 있어야 하고 수정하려는 도큐먼트는 그 유저의 것이어야 한다.
        return (userId && doc.owner === userId);
      },
      update: function (userId, docs, fields, modifier) {
        // 자신의 도큐먼트만 수정할 수 있다.
        return _.all(docs, function(doc) {
          return doc.owner === userId;
        });
      },
      remove: function (userId, docs) {
        // 자신의 도큐먼트만 삭제할 수 있다.
        return _.all(docs, function(doc) {
          return doc.owner === userId;
        });
      },
      fetch: ['owner']
    });

    Posts.deny({
      update: function (userId, docs, fields, modifier) {
        // 다른 이의 것은 변경할 수 없다.
        return _.contains(fields, 'owner');
      },
      remove: function (userId, docs) {
        // 잠겨있는(locked) 도큐먼트는 삭제할 수 없다.
        return _.any(docs, function (doc) {
          return doc.locked;
        });
      },
      fetch: ['locked'] // no need to fetch 'owner'
    });

만약 컬렉션에 `allow`룰을 하나도 만들지 않았다면 그 콜렉션에는 클라이언트에서는 아무것도 쓸수
없고 서버에서만 쓰기 연산이 가능하다. 이런 경우 클라이언트가 사용할 수 있는 쓰기 메서드를 
만들어줘야 한다. 이런 메서드는 콜렉션의 메서드인 `insert`나 `update`, `remove`를 직접 
부르는게 아니라 `Meteor.call`을 이용해서 호출할 수 있다.

Meteor에서는 빠른 프로토타이핑을 위해 "비보안 모드"라는 것도 제공한다. 비보안 모드에서는 
컬렉션에 아무런 `allow`나 `deny`룰을 적용하지 않아도 사용자가 컬렉션에 쓰기 연산을 할 
수 있다. 비보안 모드는 그게 다다. 만약 한 콜렉션에 `allow`나 `deny`를 호출한다면 
(`Post.allow({})`라고 호출하기만 해도) 일반 콜렉션처럼 접근 권한을 체크한다. __새로운 
Meteor 프로젝트는 기본적으로 비보안 모드에서 시작한다.__ 이 모드에서 빠져나가려면 
`meteor remove insecure`만 실행하면 된다.

{{#note}}
`update`나 `remove`에서 도큐먼트는 `allow`와 `deny`룰을 실행하기 위해 도큐먼트를 
가져올 때와 실제로 메서드가 실행될 때 셀렉터와 일치하는 도큐먼트들만 영향을 받는다. 다음과 
같이 셀렉터를 재작성해서 만들었다.
`{$and: [(셀렉터 원본), {$in: {_id: [(가져오거나 allow, deny룰로 체크한 도큐먼트들의 id)]}}]}`
{{/note}}

{{> api_box deny}}

`allow`룰에서 쓰기 연산을 허가했더라도 여기에서 거부를 하면 거부된다는 것만 빼면
[`allow`](#allow)와 똑같이 동작한다.

클라이언트에서 컬렉션에 쓰기연산을 하려할때 Meteor 서버는 컬렉션의 `deny`룰을 먼저 
검사한다. 만약 true를 리턴한 룰이 없다면 다음에는 `allow`룰을 검사한다. 모든 
`deny`룰이 `true`를 리턴하지 않고 적어도 하나 이상의 `allow`룰이 `true`를 
리턴해야 비로소 쓰기 연산이 가능하다.


<h2 id="meteor_collection_cursor"><span>Cursors</span></h2>

[`find`](#find)를 사용하면 커서가 만들어진다. 커서에서 [`forEach`](#foreach),
[`map`](#map), [`fetch`](#fetch)를 사용해서 도큐먼트에 접근할 수 있다.

{{> api_box cursor_foreach}}

Reactive 컨텍스트에서 `forEach`를 호출하면 해당 도큐먼트의 의존성이 모두 등록된다.

예제:

    // Print the titles of the five top-scoring posts
    var topPosts = Posts.find({}, {sort: {score: -1}, limit: 5});
    var count = 0;
    topPosts.forEach(function (post) {
      console.log("Title of post " + count + ": " + post.title);
      count += 1;
    });

{{> api_box cursor_map}}

Reactive 컨텍스트에서 `map`를 호출하면 해당 도큐먼트의 의존성을 모두 등록한다.

<!-- The following is not yet implemented, but users shouldn't assume
sequential execution anyway because that will break. -->
서버에서 `callback`이 호출 되었을때, 첫 번째 호출이 잠시 멈춰있더라도 다음 
`callback`은 계속 호출된다. 만약 순차적 실행을 엄격하게 보장받아야 한다면 
`forEach`를 이용해라. 

{{> api_box cursor_fetch}}

Reactive 컨텍스트에서 `fetch`를 호출하면 해당 도큐먼트의 의존성을 모두 등록한다.

{{> api_box cursor_count}}

    // Display a count of posts matching certain criteria. Automatically
    // keep it updated as the database changes.
    var frag = Meteor.render(function () {
      var highScoring = Posts.find({score: {$gt: 10}});
      return "<p>There are " + highScoring.count() + " posts with " +
        "scores greater than 10</p>";
    });
    document.body.appendChild(frag);

다른 함수랑 다르게 `count`는 일치하는 도큐먼트의 개수에만 의존성을 등록한다.
도큐먼트 순서를 바꾸거나 update하는 것으로는 무효화되지 않기 때문에 다시 렌더링하지 않는다.

{{> api_box cursor_rewind}}

커서에서 `forEach`, `map`, `fetch` 메소드는 딱 한 번만 호출할 수 있다.
한번 호출하고 또 호출하려면 `rewind` 함수로 커서를 리셋해야 한다.

{{> api_box cursor_observe}}

데이터를 변경시키는 쿼리를 콜백으로 알려주는 *라이브 쿼리*를 생성한다.

`callbacks`의 프로퍼티 함수는 다음과 같다:

<dl class="callbacks">
{{#dtdd "added(document, beforeIndex)"}}
도큐먼트가 새로 추가되면 호출된다. 이 도큐먼트는 `beforeIndex` 위치에 있던 도큐먼트
바로 앞에 삽입된다. 이 도큐먼트가 리스트의 맨 끝에 삽입되면 `beforeIndex`는 삽입하기 전
리스트의 길이와 같다.
{{/dtdd}}

{{#dtdd "changed(newDocument, atIndex, oldDocument)"}}
`atIndex` 위치에 있는 도큐먼트가 변경될 때 호출된다. 도큐먼트의 내용이 원래는
oldDocument이었고 `newDocument`로 변경됐다는 의미다.
{{/dtdd}}

{{#dtdd "moved(document, oldIndex, newIndex)"}}
도큐먼트의 위치가 변경될 때 호출된다. `oldIndex`에서 `newIndex`로 위치가 변경된다.
그리고 편의상 도큐먼트의 내용도 `document`에 넘어온다. 이 콜백은 `changed`가 호출된
후에 곧바로 호출된다.
{{/dtdd}}

{{#dtdd "removed(oldDocument, atIndex)"}}
`atIndex`에 있는 도큐먼트가 삭제될 때 호출된다. 해당 도큐먼트의 내용은
`oldDocument`이고 아예 삭제된다.
{{/dtdd}}
</dl>

쿼리 결과에 영향을 주기 때문에 `added`는 즉시 호출된다.

`observe`는 라이브 쿼리의 핸들을 리턴하고 그 핸들에는 `stop` 메소드가 있다.
아규먼트 없이 stop 메소드를 호출하면 더는 콜백이 호출되지 않고 쿼리 객체도 해제된다.
**라이브 쿼리는 `stop` 함수가 호출될 때까지 영원히 유지된다.**

예제:

    // Keep track of how many administrators are online.
    var count = 0;
    var query = Users.find({admin: true, onlineNow: true});
    var handle = query.observe({
      added: function (user) {
        count++;
        console.log(user.name + " brings the total to " + count + " admins.");
      },
      removed: function () {
        count--;
        console.log("Lost one. We're now down to " + count + " admins.");
      }
    });

    // After five seconds, stop keeping the count.
    setTimeout(function () {handle.stop();}, 5000);

{{#api_box_inline selectors}}

거두절미하고 말하자면 selector는 도큐먼트를 검색할 때 사용하는 키다:

    // Matches all documents where deleted is false
    {deleted: false}

    // Matches all documents where the name and cognomen are as given
    {name: "Rhialto", cognomen: "the Marvelous"}

    // Matches every document
    {}

좀 더 꼼꼼하게 검색할 수 있다:

    // Matches documents where age is greater than 18
    {age: {$gt: 18}}

    // Also matches documents where tags is an array containing "popular"
    {tags: "popular"}

    // Matches documents where fruit is one of three possibilities
    {fruit: {$in: ["peach", "plum", "pear"]}}

자세한 내용은 [mongo 문서](http://www.mongodb.org/display/DOCS/Advanced+Queries)를 봐라.

{{/api_box_inline}}

{{#api_box_inline modifiers}}

modifier는 어떻게 도큐먼트를 업데이트해야 하는지를 명시하는 객체다.
어떤 필드를 어떻게 업데이트해야 하는지 표현한다:

    // Set the 'admin' property on the document to true
    {$set: {admin: true}}

    // Add 2 to the 'votes' property, and add "Traz" to the end of the
    // 'supporters' array
    {$inc: {votes: 2}, $push: {supporters: "Traz"}}

만약 modifier에서 $-오퍼레이터를 빼먹으면 일반 도큐먼트로 해석된다.
그래서 DB에 원래 있던 도큐먼트를 통째로 바꿔버린다. (일반 도큐먼트 modifire는 현재 [버전](#allow)에서 지원하지 않는다.)

    // Find the document with id "123", and completely replace it.
    Users.update({Id: "123"}, {name: "Alice", friends: ["Bob"]});

나머지 [modifier에
대해서는 mongo 문서](http://www.mongodb.org/display/DOCS/Updating#Updating-ModifierOperations)를 봐라.

{{/api_box_inline}}

{{#api_box_inline sortspecifiers}}

정렬 기준을 명시하는 방법은 한 가지가 아니고 다음과 같다:

    // All of these do the same thing (sort in ascending order by
    // key "a", breaking ties in descending order of key "b")

    [["a", "asc"], ["b", "desc"]]
    ["a", ["b", "desc"]]
    {a: 1, b: -1}

Javascript에서는 키의 순서가 마지막 방법에서만 동작한다.
보통은 마지막 방법만 쓰고 그거면 된다. 못 믿겠으면 확인해보등가.

{{/api_box_inline}}

{{#api_box_inline fieldspecifiers}}

서버에서는 특정 필드가 있는 도큐먼트나 특정 필드가 없는 도큐먼트를 선택적으로
검색할 수 있지만 Minimongo는 이 field specifier를 무시한다.

다음과 같이 키에 필드 이름을 넣고 값에 `0`을 넣으면 해당 필드가 있는 도큐먼트는 제외된다.

    // Users.find({}, {fields: {password: 0, hash: 0}})

다음과 같이 키에 필드 이름을 넣고 값에 `1`을 넣으면 해당 필드가 있는 도큐먼트만 검색된다.

    // Users.find({}, {fields: {firstname: 1, lastname: 1}})

하지만, 이 두 표현을 섞어 쓸 수는 없다.

{{/api_box_inline}}

<h2 id="session"><span>Session</span></h2>

`Session`은 글로벌 객체이고 키-밸류 형태로 데이터를 저장한다.
`Session`은 리스트에서 현재 선택한 아이템 같은 것을 저장해둔다거나 하는데 사용한다.

`Session`도 Reactive라는 것이 중요하다. 템플릿에
[`Session.get`](#session_get)`("currentList")`라고 호출하는 코드가 있으면
[`Session.set`](#session_set) `("currentList", x)`이 호출될 때마다 템플릿을 다시 렌더링한다.

{{> api_box set}}

예제:

    Meteor.autosubcribe(function () {
      Meteor.subscribe("chat-history", {room: Session.get("currentRoomId")});
    });

    // Causes the function passed to Meteor.autosubscribe to be re-run, so
    // that the chat-history subscription is moved to the room "home".
    Session.set("currentRoomId", "home");

[`Meteor.deps`](#meteor_deps)을 보면 관련 예제가 더 있다.

{{> api_box get}}

예제:

    Session.set("enemy", "Eastasia");
    var frag = Meteor.render(function () {
      return "<p>We've always been at war with " +
        Session.get("enemy") + "</p>";
    });

    // Page will say "We've always been at war with Eastasia"
    document.body.append(frag);

    // Page will change to say "We've always been at war with Eurasia"
    Session.set("enemy", "Eurasia");

{{> api_box equals}}

만약 value가 스칼라라면 다음 두 코드는 똑같이 동작한다.

    (1) Session.get("key") === value
    (2) Session.equals("key", value)

하지만, 두 번째가 더 낫다. 무효화를 더 드물게 발생시켜서 더 효율적인 프로그램이 된다.

예제:

    <template name="postsView">
    {{dstache}}! Show a dynamically updating list of items. Let the user click on an
        item to select it. The selected item is given a CSS class so it
        can be rendered differently. }}

    {{dstache}}#each posts}}
      {{dstache}}> postItem }}
    {{dstache}}/each}}
    </{{! }}template>

    <template name="postItem">
      <div class="{{dstache}}postClass}}">{{dstache}}title}}</div>
    </{{! }}template>

    ///// in JS file
    Template.postsView.posts = function() {
      return Posts.find();
    };

    Template.postItem.postClass = function() {
      return Session.equals("selectedPost", this._id) ?
        "selected" : "";
    };

    Template.postItem.events({
      'click': function() {
        Session.set("selectedPost", this._id);
      }
    });

    // Using Session.equals here means that when the user clicks
    // on an item and changes the selection, only the newly selected
    // and the newly unselected items are re-rendered.
    //
    // If Session.get had been used instead of Session.equals, then
    // when the selection changed, all the items would be re-rendered.

객체와 배열 세션 값에 대해서는 `Session.equals`를 사용할 수 없다. 대신 
`underscore` 패키지를 추가한 다음에 `_.isEqual(Session.get(key), value)`
를 이용해서 비교할 수 있다.


<h2 id="accounts_api"><span>Accounts</span></h2>

Meteor의 계정 시스템은 [`publish`](#publish_userId)와 [`methods`](#method_userId)에서
`userId`를 지원하는 것에서 시작한다. 유저 도큐먼트를 데이터베이스에 저장한다는 개념이 
코어 패키지에 추가되었고, [secure password authentication](#accounts_passwords)과 
[서드 파티 로그인 시스템과 결합](#meteor_loginwithexternalservice), 
[미리 만들어진 UI](#accountsui)와 같은 패키지가 추가되었다.

기본 계정 시스템을 사용하려면 `accounts-base` 패키지를 사용하면 된다. 그런데 보통 
앱에 로그인 프로바이더 패키지인 `accounts-password`나 `accounts-facebook`, 
`accounts-github`, `accounts-google`, `accounts-twitter`, `accounts-weibo` 
중 하나라도 추가해서 사용한다면 이 패키지는 자동으로 추가된다. 
 
{{> api_box user}} 

[`Meteor.users`](#meteor_users) 컬렉션에서 현재 유저의 
유저 레코드를 받아온다.

클라이언트에서 받는 값은 그 도큐먼트에 있는 일부 필드뿐이다. 오직 서버에서 그 
클라이언트에게 허락한(publish) 값만 사용가능하다. 기본값으로 서버는 `username`과 
`emails`, `profile`필드를 publish한다. 유저 도큐먼트의 필드에 대한 자세한 
정보는 [`Meteor.users`](#meteor_users)를 참고하라.

만약 유저가 로그인 상태이면서 데이터베이스로부터 유저의 레코드를 다 받아오지 않은 
상태라면 이 메서드는 `_id`필드만 세팅된 객체를 리턴한다. 이 구간에서는 
[`userLoaded`](#meteor_userloaded)가 false를 리턴한다.
 
{{> api_box userId}} 
 
{{> api_box users}} 
 
이 컬렉션은 등록된 유저당 하나의 도큐먼트를 저장하는 컬렉션이다. 아래에 
유저 도큐먼트가 어떻게 생겼는지에 대한 예제가 있다.
 
    { 
      _id: "bbca5d6a-2156-41c4-89da-0329e8c99a4f",  // Meteor.userId() 
      username: "cool_kid_13", // 유니크한 이름
      emails: [ 
        // 각 이메일은 한 유저에게 연관된다.
        { address: "cool@example.com", verified: true }, 
        { address: "another@different.com", verified: false } 
      ], 
      createdAt: 1349761684042, 
      profile: { 
        // 기본적으로 유저가 프로필을 작성할 수 있다.
        name: "Joe Schmoe" 
      }, 
      services: { 
        facebook: { 
          id: "709050", // facebook id 
          accessToken: "AAACCgdX7G2...AbV9AZDZD" 
        }, 
        resume: { 
          loginTokens: [ 
            { token: "97e8c205-c7e4-47c9-9bea-8e2ccc0694cd", 
              when: 1349761684048 } 
          ] 
        } 
      } 
    } 
 
하나의 유저 도큐먼트는 유저에 대한 것이라면 어떠한 데이터든 담을 수 있다. 단, 아래의 
필드들은 특별한 필드들이다.
 
- `username`: 유저의 ID. 시스템 내에서 유일해야한다.
- `emails`: `address`와 `verified`를 키로 가지는 객체의 배열. 하나의 이메일 
  주소는 반드시 단 하나의 유저에게 소속되어야 한다. `verified`는 이메일로 보낸 토큰을 
  이용해 [확인된 이메일](#accounts_verifyemail)인지 나타내는 불리언 값이다.
- `createdAt`: 유저 도큐먼트가 생성된 시각의 타임스탬프 (1970년 1월 1일부터 흐른 
  시간의 밀리초 값)
- `profile`: 해당 유저가 조작할 수 있는 오브젝트. 어떠한 데이터라도 들어갈 수 있다.
- `services`: 특정 로그인 서비스에서 사용하는 데이터를 담은 객체. 예를 들어서 
  `reset` 필드는 [forgot password](#accounts_forgotpassword) 링크에서 
  사용할 토큰을 담고 있고, `resume` 필드는 세션을 넘나들며 로그인을 유지하기 위한 
  토큰을 가지고 있다.

다른 모든 [Meteor.Collection](#collections)들과 같이 서버의 모든 도큐먼트에 
접근이 가능하지만 그중에서도 특별히 서버가 publish한 것에만 접근이 가능하다.

현재 유저의 `username`과 `emails`, `profile`필드만 publish되는 것이 기본 설정이다.
아래와 같은 코드를 이용해 더 많은 필드를 클라이언트로 보낼 수 있다.
 
    Meteor.publish("userData", function () { 
      return Meteor.users.find({_id: this.userId}, 
                               {fields: {'other': 1, 'things': 1}}); 
    }); 

만약 `autopublish` 패키지가 추가되어잇다면 모든 유저의 `username`과 `profile`
필드는 접속해있는 모든 클라이언트로 publish된다. 모든 유저의 특정 필드만 publish하려면 
다음과 같이 쓴다.
 
    Meteor.publish("allUserData", function () { 
      return Meteor.users.find({}, {fields: {'nested.things': 1}}); 
    }); 

기본적으로 유저는 [`Accounts.createUser`](#accounts_createuser)가 호출될 때 
자신의 `profile`필드를 채워넣을 수 있다. 그리고 `Meteor.users.update`로 그 값을 
수정할 수 있다. 다른 필드에 까지 수정 권한을 주려면 [`Meteor.users.allow`](#allow)를 
이용해야 한다. 유저에게서 자신의 정보에 대한 수정 권한을 전부 빼앗으려면 아래와 같이 쓴다.
 
    Meteor.users.deny({update: function () { return true; }}); 

{{> api_box userLoaded}} 

클라이언트가 로그인한 유저의 아이디는 아는데 유저의 데이터를 아직 다 받지는 못하는 경우가 
왕왕있다. 예를 들어 유저가 로그인을 하고 나서 페이지를 새로고침 하면 유저 데이터는 페이지를 
초기화 하는 동안은 사용할 수가 없다.
 
이 동안은 `userLoaded`는 false르 리턴하고 [`user`](#meteor_user)는 유저의 `_id`만 
들어있는 객체를 리턴한다.
 
{{#note}}
우리는 이런 방식이 불편하다는것을 안다. 이건 임시적인 해결책이다. 나중에는 이 메서드가 필요없도록 
만들면서 다른 일반적인 매커니즘으로 해결할 예정이다.
{{/note}} 
 
{{> api_box logout}} 
 
{{> api_box loginWithPassword}} 

이 함수는 `accounts-password` 패키지에서 제공한다. 아래의 [Passwords](#accounts_passwords) 
섹션을 참고하길 바란다.

 
{{> api_box loginWithExternalService}} 

이 함수들을 이용해 OAuth를 이용한 외부 서비스들(예: Facebook, Google등)를 이용해 로그인한다.
이 함수들을 호출하면 팝업 윈도우를 열어 프로바이더의 로그인 페이지로 연결해준다. 프로바이더 페이지에서
유저가 로그인하면 팝업 윈도우는 닫히고 Meteor 클라이언트는 외부 서버에서 전해준 정보들을 기반으로
Meteor 서버로 로그인한다.
 
<a id="requestpermissions" name="requestpermissions" /> 

또 어떤 서비스는 유저에게서 정보를 얻어낼 수 있는 API를 제공한다. 
유저에게 특정 권한을 요구할 때 로그인 함수에 `requestPermissions` 옵션을 넘긴다. 
그러면 유저는 팝업 다이얼로그에서 자신의 데이터 접근을 요구하는 화면을 보게 된다. 유저의 
`accessToken`을 유저 도큐먼트의 `services`필드에 저장하고 이 `accessToken`을 
이용해 프로바이더 서비스의 API를 사용할 수 있다. `requestPermissions`에서 사용할 
수 있는 값들은 로그인 서비스마다 다르다. 그에 대한 문서는 각 서비스의 개발자 사이트에 있다.
 
- Facebook: <http://developers.facebook.com/docs/authentication/permissions/> 
- GitHub: <http://developer.github.com/v3/oauth/#scopes> 
- Google: <https://developers.google.com/accounts/docs/OAuth2Login#scopeparameter> 
- Twitter, Weibo: 현재 `requestPermissions`를 지원하지 않는다. 

보통 외부 로그인 서비스를 사용하기 전에는 해당 서비스에 등록 후 설정과정을 거쳐야 한다. 
가장 쉬운 방법은 서비스를 설정하기 위한 단계별 가이드를 제공하는 [`accounts-ui` 패키지](#accountsui)를 
사용하는 것이다. 그러지 않고 데이터를 직접 `Accounts.loginServiceConfiguration` 
콜렉션에 하나하나 집어넣어도 된다. 예를 들자면 아래와 같다.
 
    Accounts.loginServiceConfiguration.insert({ 
      service: "weibo", 
      clientId: "1292962797", 
      secret: "75a730b58f5691de5522789070c319bc" 
    }); 
 

Meteor에는 각 외부 서비스를 지원하는 로그인 프로바이더 패키지와 로그인 함수가 있다. 
GitHub를 예로 들어보자. 로그인 기능을 넣으려면 `$ meteor add accounts-github`를 
실행하고 `Meteor.loginWithGithub` 함수를 사용한다.
 
    Meteor.loginWithGithub({ 
      requestPermissions: ['user', 'public_repo'] 
    }, function (err) { 
      if (err) 
        Session.set('errorMessage', err.reason || 'Unknown error'); 
    }); 
 
 
 
{{> api_box accounts_config}} 
{{> api_box accounts_ui_config}} 
 
예제: 
 
    Accounts.ui.config({ 
      requestPermissions: { 
        facebook: ['user_likes'], 
        github: ['user', 'repo'] 
      }, 
      passwordSignupFields: 'USERNAME_AND_OPTIONAL_EMAIL' 
    }); 
 
{{> api_box accounts_validateNewUser}} 
 
이 함수는 여러번 호출할 수 있다. 만약 어떤 함수가 `false`를 리턴하거나 에러를 던지면 
새로운 유저는 생성되지 않는다. 에러 메세지가 필요하다면 [`Meteor.Error`](#meteor_error)를 
만들어서 던지면 된다. 이 메세지는 [`accounts-ui`](#accountsui)를 이용해서 출력할 수 있다.
 
예제: 
 
    // Validate username, sending a specific error message on failure. 
    Accounts.validateNewUser(function (user) { 
      if (user.username && user.username.length >= 3) 
        return true; 
      throw new Meteor.Error(403, "Username must have at least 3 characters"); 
    }); 
    // Validate username, without a specific error message. 
    Accounts.validateNewUser(function (user) { 
      return user.username !== "root"; 
    }); 
 
{{> api_box accounts_onCreateUser}} 
 
새로운 유저를 생성할 때, 단순히 허가/거부와 같은 결정보다 더 많은 일을 하려면 바로 
이 함수를 사용하면 된다. 이 함수를 이용해 새로운 유저 도큐먼트의 내용을 풍부하게 채울 수 있다.

이 함수엔 `options`와 `user` 아규먼트가 필요하다. `options`는 패스워드 기반 유저를 위한 
[`Accounts.createUser`](#accounts_createuser)나 외부 서비스 로그인 과정에서 나오는 
값이다. `options`값은 인증되지 않은 클라이언트에서 날아온다. 따라서 이 값은 믿을 수가 없으므로 
`options`는 모든 값을 확인해봐야한다. `user` 아규먼트는 서버에서 만들어진다. 이 아규먼트는 
로그인하는데에 필요한 모든 정보가 자동으로 채워진 유저 객체이다.
 
어떤 수정사항이 있던간에 함수는 유저 도큐먼트를 리턴해야한다.(새로 만들어진 사용자든, 한번 
로그인했던 사용자든 관계없이) 리턴한 도큐먼트는 곧바로 [`Meteor.users`](#meteor_users) 
컬렉션으로 들어간다.

기본적인 유저 생성 함수는 단순히 `options.profile`를 새로운 유저 도큐먼트로 복사하는 일을 한다. 
`onCreateUser`를 이용해서 기본 동작을 덮어쓴다. 이 함수는 한 번 만 호출할 수 있다.
 
예제: 
 
<!-- XXX replace d6 with _.random once we have underscore 1.4.2 --> 
 
    // Support for playing D&D: Roll 3d6 for dexterity 
    Accounts.onCreateUser(function(options, user) { 
      var d6 = function () { return Math.floor(Math.random() * 6) + 1; }; 
      user.dexterity = d6() + d6() + d6(); 
      // We still want the default hook's 'profile' behavior. 
      if (options.profile) 
        user.profile = options.profile; 
      return user; 
    }); 
 
 
<h2 id="accounts_passwords"><span>Passwords</span></h2> 
 
`accounts-password` 패키지는 패스워드 기반 인증을 하기 위한 모든 기능을 담고 있다. 
게다가 이름/패스워드 기반 로그인 과정과 이메일 기반 로그인(메일 주소 확인까지), 이메일을 
이용한 패스워드 복구 기능까지 포함한다.
 
다른 수많은 웹 앱과는 다르게, Meteor 클라이언트는 서버로 사용자의 패스워드를 그냥 보내지 않는다.
서버가 절대로 유저의 패스워드를 날 것으로 보지 못하도록 Meteor는 
[Secure Remote Password protocol](http://en.wikipedia.org/wiki/Secure_Remote_Password_protocol)를 
사용한다. 이 프로토콜을 이용하면 서버에서 패스워드가 유출되더라도 상관이 없다.

앱에서 패스워드 기능을 지원하려면 `$ meteor add accounts-password`를 실행한다.
UI를 개발자가 만들어 아래의 함수들을 붙여서 사용할 수도 있고 [`accounts-ui` 패키지](#accountsui)를 이용할 수도 있다. `accounts-ui` 패키지에는 패스워드 기반의 로그인 UI가 다 만들어져 있어 그냥 쓰면 된다.

 
{{> api_box accounts_createUser}} 
 
클라이언트에서는 이 함수를 이용해 방금 가입한 유저들을 로그인시킨다. 서버에서는 새로 가입한 
유저의 아이디를 리턴한다.
 
클라이언트에서는 반드시 `password`과 `username`/`email`중 하나를 아규먼트로 넘겨야 한다.
이 때 넘긴 값으로 다음에 로그인 해야한다. 서버에서는 이 옵션들의 서브셋을 넘길 수 있다. 하지만
유저는 아이디와 패스워드를 넘기기전까진 로그인 할 수 없다.

서버에서 패스워드 없이 계정을 만들려면 `createUser`를 `email`옵션을 줘서 호출한 다음
[`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail)를 호출한다.
이 함수는 유저에게 패스워드 초기화 링크를 담은 이메일을 보낸다.

`profile`옵션이 새로운 유저 도큐먼트에 들어가는게 기본 동작인데 이를 바꾸려면 
[`Accounts.onCreateUser`](#accounts_createuser)를 이용하면 된다.
 
이 함수는 유저를 생성할 때 반드시 패스워드가 있어야한다. 외부 서비스로 하는 로그인 과정에서는 
이 함수를 사용하지 않는다.
 
 
{{> api_box accounts_changePassword}} 
 
{{> api_box accounts_forgotPassword}} 

이 함수는 서버에서 실행되며 [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail)를 
호출한다. 이 함수를 실행하면 유저가 이메일을 받는다. 그 이메일에서 나온 토큰을 
[`Accounts.resetPassword`](#accounts_resetpassword)에 넘기는 걸로 패스워드 리셋이 끝난다.
 
[`accounts-ui` 패키지](#pkg_accounts_ui)를 사용하면 이 과정이 자동으로 이루어진다. 
이 패키지를 사용하지 않느다면 사용자로부터 새로운 패스워드를 입력받아 `resetPassword`를 호출해주어야 한다.
 
{{> api_box accounts_resetPassword}} 

이 함수는 [`Accounts.sendResetPasswordEmail`](#accounts_sendresetpasswordemail) 
와 [`Accounts.sendEnrollmentEmail`](#accounts_sendenrollmentemail)에서 만들어진 토큰을 아규먼트로 받는다.
 
{{> api_box accounts_setPassword}} 
 
{{> api_box accounts_verifyEmail}} 

이 함수는 [`Accounts.sendVerificationEmail`](#accounts_sendverificationemail)에서
만들어진 토큰을 아규먼트로 받는다. 그리고 유저 레코드의 `emails.verified` 필드를 true로 세팅한다.
 
{{> api_box accounts_sendResetPasswordEmail}} 

이 이메일에 포함된 토큰이 [`Accounts.resetPassword`](#accounts_resetpassword)에서 사용된다.
 
이메일의 내용을 바꾸려면 [`Accounts.emailTemplates`](#accounts_emailtemplates)를 보면 된다.
 
{{> api_box accounts_sendEnrollmentEmail}} 

이 이메일의 토큰은 [`Accounts.resetPassword`](#accounts_resetpassword)에서 사용된다.
 
이메일의 내용을 바꾸려면 [`Accounts.emailTemplates`](#accounts_emailtemplates)를 보면 된다.

{{> api_box accounts_sendVerificationEmail}} 
 
이 이메일의 토큰은 [`Accounts.verifyEmail`](#accounts_verifyemail)에서 사용된다.
 
이메일의 내용을 바꾸려면 [`Accounts.emailTemplates`](#accounts_emailtemplates)를 보면 된다.

{{> api_box accounts_emailTemplates}} 
 
이것은 `sendResetPasswordEmail`이나 `sendEnrollmentEmail`, `sendVerificationEmail`에서 
보낼 이메일에 넣을 텍스트를 만들어내기 위한 몇가지 필드가 들어있는 `객체`이다.
 
이 객체의 필드에 대한 설명이 아래에 있다. 이 필드들은 사용자가 수정할 수 있다.
 
- `from`: [RFC5322](http://tools.ietf.org/html/rfc5322)에 명시된 From 주소 형식의 
   `String`이다. 기본값은 `no-reply@meteor.com`이다. 만약 유저에게서 답장을 받고싶다면 답장을 
   받을 수 있는 이메일 주소로 바꿔야 한다.
- `siteName`: 유저들에게 보여줄 앱의 이름이다. 앱의 DNS 이름이 기본값이 된다.(예: `awesome.meteor.com`)
- `resetPassword`: 필드가 두 개인 객체이다.
 - `resetPassword.subject`: 유저 `객체`를 받고 패스워드 초기화 이메일의 제목을 `문자열`로 리턴하는 `함수`이다.
 - `resetPassword.text`: 유저 객체와 url을 받아서 패스워드 초기화 이메일의 본문을 리턴하는 `함수`이다.
- `enrollAccount`: `resetPassword`와 같지만 새로운 계정의 패스워드 초기화를 할 때 사용하는 객체이다.
- `verifyEmail`: `resetPassword`와 같지만 유저의 email을 확인할 때 사용하는 객체이다.
 
예제: 
 
    Accounts.emailTemplates.siteName = "엄청난 사이트"; 
    Accounts.emailTemplates.from = "엄청난 사이트 관리자 <accounts@example.com>"; 
    Accounts.emailTemplates.enrollAccount.subject = function (user) { 
        return user.profile.name + "님, 엄청난 타운에 오신걸 환영합니다. ";
    }; 
    Accounts.emailTemplates.enrollAccount.text = function (user, url) { 
       return "당신은 더 나은 건설사업에 초대되었습니다.!
         + " 계정을 활성화하려면 다음 링크를 눌러주세요 :\n\n" 
         + url; 
    }; 
 


<h2 id="templates_api"><span>Templates</span></h2>

`<{{! }}template name="foo"> ... </{{! }}template>` 으로 정의한 템플릿은 `Template.foo` 함수를 통해서 접근할 수 있고 호출하면 HTML 스트링을 리턴한다.

같은 템플릿을 여러 번 사용할 수 있는데 그때마다 템플릿 인스턴스가 생긴다. 템플릿 인스턴스의 라이프싸이클은 생성돼서, DOM에 넣어지고, 나중에 DOM에서 제거되고, 메모리에서 해제되는 순이다. 이 라이프싸이클은 Meteor가 알아서 관리해준다. 템플릿 인스턴스를 언제 제거할지, 언제 교체할지, 언제 메모리에서 해제할지도 Meteor 결정해준다. 사용자는 템플릿 인스턴스와 데이터와 엮어 주기만 하며 되고 바로 DOM 노드에 접근해서 사용할 수 있다.

그뿐만 아니라 템플릿 인스턴스가 새로운 DOM 노드로 다시 렌더링된다고 해도 Meteor는 해당 템플릿 인스턴스와 상태를 관리해준다. 같은 방법으로 템플릿을 호출할 수 있으니까 Meteor는 인스턴스가 해제되고 다시 생성됐다고 여기지 않는다. 그리고 `preserve`와 `constant`를 사용하면 Meteor는 DOM 노드를 새로 만들지 않고 그대로 유지한다.

템플릿과 템플릿 인스턴스에 사용하는 콜백과 옵션이 많다. 어떤 콜백과 옵션이 있는지 살펴보자.

{{> api_box template_call}}

템플릿 헬퍼 안에서, `Meteor.render` 안에서, 혹은 Reactive HTML을 생성하는 어떤 곳에서 호출하면 Reactive Context가 만들어진다. Reactive Context에서 HTML을 리턴하면 거기에 Reactive 정보가 붙고 Reactive DOM 엘리먼트로 렌더링된다. 그게 아니면 HTML은 그냥 순수한 HTML이다.

 `Meteor.render` 뿐만 아니라 Reactive 컨텍스트 어디에서나 가능하고 

{{> api_box template_rendered}}

이 함수는 Template.*myTemplate* 인스턴스가 렌더링될 때 호출된다. 템플릿이 DOM 노드로 생성돼서 DOM 트리에 넣어질 때마다 호출되는 것이라서 다시 렌더링될 때도 호출된다.

콜백 안에서 `this`는 [템플릿 인스턴스](#template_inst) 객체를 가리킨다. 그래서 정확하게 템플릿이 사용된 위치를 식별할 수 있어서 렌더링될 때 데이터를 저장할 수도 있다. 템플릿 인스턴스가 만들어질 때나 해제될 때를 원한다면 `created`와 `destroyed` 콜백을 사용하라 

{{> api_box template_created}}

이 콜백은 *myTemplate* 템플릿 인스턴스가 새로 생성될 때 호출된다. 기존의 템플릿 인스턴스를 다시 랜더링할 때는 호출되지 않는다. 이 콜백에서 `this`는 [템플릿 인스턴스](#template_inst) 객체다. 객체에 프로퍼티를 추가하면 나중에 `rendered`와 `destroyed` 콜백에서도 접근할 수 있다.

이 콜백은 딱 한 번 호출되며 다른 여러 콜백 중에서 가장 먼저 호출된다. `created` 콜백과 `destroyed` 콜백은 한 쌍이다. `create` 콜백에서 초기화하고 `destoryed` 콜백에서 해제한다.

{{> api_box template_destroyed}}

이 콜백은 템플릿 인스턴스가 페이지에서 떼어져서 다시 렌더링되지 않을 때 발생한다. 떼어진 이유는 중요치 않다. 이 콜백 안에서 `this`는 해제될 [템플릿 인스턴스](#template_inst) 객체다.

`created` 콜백에서 만든 쓰레기를 청소하기엔 `destroyed`가 최적의 장소다. 이 콜백은 여러 콜백 중에서 가장 마지막에 딱 한 번만 호출된다.

{{> api_box template_events}}

이 함수로 템플릿 인스턴스에 사용될 이벤트 핸들러를 등록한다. 여러 번 호출하면 호출하는 만큼 새로운 이벤트 핸들러로 등록된다.

어떤 형식으로 [이벤트 맵](#eventmaps)을 넘겨야 하고 어떻게 핸들링해야 하는지는 [이벤트 맵](#eventmaps) 설명하는 부분을 보라.

{{#note}}
이전 버전까지는 `Template.myTemplate.events = {...}` 형식으로 사용했어야 했다. 아직은 이 예전 문법을 지원하긴 한다.
{{/note}}

{{> api_box template_helpers}}

템플릿 하나에서만 사용할 수 있는 로컬 헬퍼를 정의할 수 있다. helpers 함수를 통해서 딕셔너리 형태로 정의한다.

예제:

    Template.myTemplate.helpers({
      foo: function () {
        return Session.get("foo");
      }
    });

Handlebars에서 이 헬퍼는 `{{dstache}}foo}}` 처럼 호출할 수 있다.

다음과 같이 정의하는 것도 가능하다. 하지만, heplers 같은 특수한 프로퍼티는 사용할 수 없다.

    Template.myTemplate.foo = function () {
      return Session.get("foo");
    };

{{> api_box template_preserve}}

DOM 엘리먼트가 다시 렌더링돼도 그대로 유지할(preserve) 수 있다. 감싼 HTML이 교체돼도 해당 DOM 엘리먼트는 그대로 유지한다. 그래서 템플릿이 다시 렌더링돼도 텍스트 필드, iframe 같은 엘리먼트의 상태를 유지할 수 있다. Meteor는 Preserve 엘리먼트 주변을 패치하기 때문에 Preserve 엘리먼트는 다시 렌더링된 후에도 유지된다. 

{{#note}}
기본적으로 새로운 Meteor 앱은 `preserve-inputs` 패키지를 포함한다.  이 패키지는 `input`과 `textarea`, `button`, `select`, `option`타입의 모든 엘리먼트를 유지한다. 이 모든 엘리먼트는 유니크한 `id` 속성이나 유니크한 `id` 속성을 가진 엘리먼트안에 있는 `name` 속성을 가지는 엘리먼트 이다. 이 기능을 끄려면 그냥 `preserve-inputs` 패키지를 지운다.
{{/note}}

DOM 엘리먼트를 같지만 새로운 엘리먼트로 교체하는 것은 원래 엘리먼트를 그대로 유지하는 것과 다르다. 그래서 Preseve는 다음 같은 경우에 매우 유용하다:

* 텍스트 Input 필드 같은 폼 컨트롤
* CSS 에니메이션이 있는 엘리먼트
* Iframes
* JavaScript 코드에서 참조하는 엘리먼트

엘리먼트와 그 자식을 포함한 DOM 전체나 Meteor가 렌더링하지 않은 노드까지 유지하고 싶으면 [constant](#constant)를 사용하라.

DOM 노드를 유지하려면 템플릿의 엘리먼트에 일치하는 셀렉터 목록을 넘긴다. 넘긴 셀렉터는 템플릿이 다시 렌더링될 때 사용한다. Meteor는 HTML이 어떻게 변하든 해당 엘리먼트는 원래 엘리먼트를 재사용한다.

딕셔너리 값으로 넘기는 labeling 함수는 해당 셀렉터에 만족하는 엘리먼트가 여러 개일 때 사용한다. 노드 객체를 넘겨받고 그 노드를 식별하는 스트링을 리턴한다. 만약 `false`를 리턴하면 해당 노드는 유지하지 않는다.

예를 들어, id로 식별하면서 `foo` 템플릿의 `<input>` 엘리먼트를 전부 유지하려면 다음과 같이 사용한다:

    Template.foo.preserve({
      'input[id]': function (node) { return node.id; }
    });

셀렉터는 해당 템플릿 인스턴스 안에서만 적용된다. 템플릿 인스턴스마다 독립적이기 때문에 셀렉터는 템플릿 인스턴스 안에서만 식별할 수 있으면 된다. 전체 페이지에서 식별하지 않는다. 만약 하위 템플릿이 있으면 셀렉터는 그 하위 템플릿의 엘리먼트에도 적용한다.

엘리먼트를 유지한다고 해서 속성이나 내용까지 유지하지 않는다. 다시 렌더링할 때 업데이트가 필요하면 속성과 내용은 업데이트된다. input 엘리먼트에 포커스가 없으면 input 엘리먼트의 텍스트는 유지하지 않는다. 하지만, 커서나 셀렉션은 그대로 유지된다. Iframe은 네비게이션 상태를 유지하고 애니메이션은 아무것도 변하지 않은 것처럼 계속 실행한다.

DOM API의 한계 때문에 어쩔 수 없이 유지 못 할 수도 있다. 엘리먼트 태그의 이름은 변경할 수 없고 다른 부모 밑으로 옮길 수도 없다. 그러니까 노드가 다시 정렬돼야 한다거나 부모를 바꿔야 하면 유지되지 않는다.

{{#note}}
이전 버전에서는 불명확하게 "id"와 "name" 속성을 Preserve 디렉티브로 사용했었다. 지금은 명시적으로 선택하는 방법으로 변경됐다.
{{/note}}

<h2 id="template_inst"><span>Template instances</span></h2>

템플릿을 사용할 때마다 템플릿 인스턴스가 생성된다. 템플릿 인스턴스를 통해 해당 DOM에 접근할 수 있을 뿐만 아니라 템플릿 인스턴스에 프로퍼티를 할당할 수도 있다. 그래서 다시 렌더링하는 동안에 데이터를 저장해둘 수 있다.

`created`, `rendered`, `destroyed` 템플릿 콜백에서는 `this`가 템플릿 인스턴스를 가리키고 이벤트 핸들러에는 아규먼트로 넘겨진다.

아래에서 설명하는 함수와 프로퍼티말고 다른 프로퍼티와 함수는 마음대로 추가할 수 있다. 프로퍼티 이름만 `_`로 시작하게 지어서 사용자가 만들었음을 표시하라. 그리고 초기화나 객체를 해제하는 것은 `created`와 `destroyed` 콜백을 사용한다.

`findAll`, `find`, `firstNode`, `lastNode` 함수는 `rendered` 콜백과 이벤트 핸들러에서만 사용할 수 있다. 이 함수를 사용하려면 템플릿 인스턴스가 DOM 안에 있어야 하기 때문에 `created`와 `destroyed` 콜백에서는 사용할 수 없다.

{{> api_box template_findAll}}

`selector`에 일치하는 DOM 엘리먼트를 배열에 담아 리턴한다.

셀렉터가 적용되는 DOM 루트는 템플릿 인스턴스다. 하위 템플릿까지 포함해서 템플릿안에 있는 엘리먼트에만 질의한다.

{{> api_box template_find}}

`selector`에 일치하는 DOM 엘리먼트 한 개를 리턴한다. 일치하는 엘리먼트가 없으면 `null`을 반환한다.

셀렉터가 적용되는 DOM 루트는 템플릿 인스턴스다. 하위 템플릿까지 포함해서 템플릿안에 있는 엘리먼트에만 질의한다.

{{> api_box template_firstNode}}

`firstNode`와 `lastNode`는 템플릿을 DOM으로 렌더링했을 때 범위를 나타낸다. 렌더링한 템플릿은 이 두 노드와 사이의 다른 노드들 그리고 그 외 자식(descendent) 노드로 구성된다. `firstNode`와 `lastNode`는 부모가 같고 `firstNode` 다음에 `lastNode`가 온다. 그게 아니면 두 노두가 같을 수 있다.

{{> api_box template_lastNode}}

{{> api_box template_data}}

이 프로퍼티는 템플릿의 데이터 컨텍스트다. 템플릿이 렌더링될 때마다 변경된다. 그리고 Reactive 데이터 소스가 아니고 읽을 수만 있다.
????
{{> api_box render}}

`Meteor.render`는 실시간으로 자동 업데이트를 수행하는 `DocumentFragment`를 하나 생성한다. 대부분의 Meteor 앱은 이 함수를 직접호출 하지 않는다. 템플릿을 사용하면 Meteor가 렌더링하는 부분을 관리해준다.

HTML 스트링을 리턴하는 함수 `htmlFunc`를 아규먼트로 넘긴다. `Meteor.render`는 그 함수를 실행해서 HTML 스트링을 얻어서 DOM 노드를 만든다. 이때 자동으로 htmlFunc 함수에서 사용한 데이터를 추적하고 그 데이터와 콜백을 엮는다. 그래서 데이터가 변하면 htmlFunc 함수가 다시 실행돼서 DOM 노드가 바로 업데이트된다.

리턴한 `DocumentFragment`를 원하는 DOM 위치에 넣는다. 그 삽입된 노드는 화면에서 사라질(take off the screen)때까지 계속 업데이트된다. 사라지면 자동으로 정리된다. 자세한 건 [`Meteor.flush`](#meteor_flush)를 봐라.

`Meteor.render`는 Reactive 컨텍스트에서 실행하는 것이라서 htmlFunc의 데이터 의존성을 추적한다. 그래서 `Meteor.render`는 htmlFunc 함수에서 사용한 Reactive 데이터 소스가 변경되는 것을 처리할 수 있다. Reactive 데이터 소스를 직접 만들려면 [Reactivity](#reactivity)를 봐라.

예제:

    // Show the number of users online.
    var frag = Meteor.render(function () {
      return "<p>There are " + Users.find({online: true}).count() +
        " users online.</p>";
    });
    document.body.appendChild(frag);

    // Find all users that have been idle for a while, and mark them as
    // offline. The count on the screen will automatically update.
    Users.update({idleTime: {$gt: 30}}, {online: false});

{{> api_box renderList}}

이 함수는 DB 쿼리 결과가 변경되면 자동으로 업데이트하는 `DocumentFragment`를 생성한다. 보통은 이 함수을 직접 호출하지 않고 템플릿에서 `{{dstache}}#each}}`를 사용하면 이 함수가 사용된다.

DB 도큐먼트를 여러 개 렌더링할 때에는 `renderList`가 `Meteor.render`보다 효율적이다. 예를 들어, 어떤 쿼리에 만족하는 도큐먼트가 DB에 새로 추가되면 전체가 아니라 그 도큐먼트에 해당하는 부분만 다시 렌더링된다. 다른 엘리먼트는 건드리지 않는다. 정렬하는 쿼리를 실행하고 있을 때 도큐먼트 순서가 바뀌면 다시 렌더링하는 것이 아니라 단순히 DOM 노드를 옮길 뿐이다.

도큐먼트를 하나씩 HTML로 생성할 때마다 `docFunc`를 호출하고 쿼리 결과가 없을 때에는 `elseFunc`를 호출한다. `elseFunc`는 결과가 없을 때에는 다른 화면을 보여주는 용도로 사용한다. 예를 들어, "절대 결과가 없을 리 없다." 같은 메시지를 보여줄 수 있다.

`docFunc`나 `elseFunc` 함수는 각각 다른 Reactive 컨텍스트에서 실행된다. 그래서 데이터가 변경되면 해당 Reactive 컨텍스트만 다시 렌더링 된다.

예제:

    // List the titles of all of the posts that have the tag
    // "frontpage". Keep the list updated as new posts are made, as tags
    // change, etc.  Display the selected post differently.
    var frag = Meteor.renderList(
      Posts.find({tags: "frontpage"}),
      function(post) {
        var style = Session.equals("selectedId", post.Id) ? "selected" : "";
        // A real app would need to quote/sanitize post.name
        return '<div class="' + style + '">' + post.name + '</div>';
      });
    document.body.appendChild(frag);

    // Select a post.  This will cause only the selected item and the
    // previously selected item to update.
    var somePost = Posts.findOne({tags: "frontpage"});
    Session.set("selectedId", somePost.Id);

{{#api_box_inline eventmaps}}

이벤트 맵은 객체다. 이 객체의 프로퍼티 이름은 처리할 이벤트이고
그 값은 이벤트 핸들러다. 프로퍼티 이름은 다음과 같이 명시한다:

<dl>
{{#dtdd "<em>eventtype</em>"}}
'click' 같은 이벤트 타입
{{/dtdd}}

{{#dtdd "<em>eventtype selector</em>"}}
명시한 CSS Selector의 엘리먼트에서 발생하는 이벤트 타입
{{/dtdd}}

{{#dtdd "<em>event1, event2</em>"}}
콤마로 구분해서 핸들할 이벤트 타입을 나열한다.
{{/dtdd}}
</dl>

핸들러 함수는 아규먼트를 두 개 받는다. `event` 아규먼트는 이벤트 객체이고 `template` 아규먼트는 핸들러를 정의한 해당 [템플릿 객체](#template_inst)이다. 그리고 핸들러는 `this`를 통해서 해당 엘리먼트에 대한 컨텍스트 데이터에도 접근할 수 있다. Handlebars 템플릿에서는 엘리먼트 컨텍스트가 곧 Handlebars 데이터 컨텍스트이고 `#with`나 `#each` 같은 블럭 헬퍼에 따라 데이터 컨텍스트가 변경된다.

예제:

    {
      // Fires when any element is clicked
      'click': function (event) { ... },

      // Fires when any element with the 'accept' class is clicked
      'click .accept': function (event) { ... },

      // Fires when 'accept' is clicked, or a key is pressed
      'keydown, click .accept': function (event) { ... }
    }

이벤트는 원래 이벤트가 발생한 엘리먼트에서 DOM 트리를 따라
전파된다(bubble up). 예를 들어 `click p`는 단락 태그인 `<p>` 블럭에서
발생한 click 이벤트를 캐치한다. 심지어 그 단락 안에 있는 `<a>`, `<span>`
등등의 엘리먼트에서 발생한 click 이벤트도 캐치한다. 원래 이벤트가 발생한
엘리먼트는 `target` 프로퍼티로 알 수 있고 Selector와 일치한 엘리먼트는
`currentTarget` 프로퍼티로 알 수 있다.

    {
      'click p': function (event) {
        var paragraph = event.currentTarget; // always a P
        var clickedElement = event.target; // could be the P or a child element
      }
    }

이벤트가 전파하는 엘리먼트에 따라서 일치하는 Selector가 여러 개면 핸들러는
그 수만큼 호출된다. `click div`이나 `click *`은 아마 여러 번 호출될
것이다. Selector가 없으면 Handler는 원래 이벤트가 발생한 target
엘리먼트에서 한 번만 호출된다.

핸들러에 넘어오는 이벤트 객체에 있는 프로퍼티와 메소드는 다음과 같다:

<dl class="objdesc">
{{#dtdd name="type" type="String"}}
"click", "blur", "keypress" 같은 이벤트 타입
{{/dtdd}}

{{#dtdd name="target" type="DOM Element"}}
이벤트가 최초 발생한 DOM 엘리먼트
{{/dtdd}}

{{#dtdd name="currentTarget" type="DOM Element"}}
지금 이 이벤트를 핸들하는 엘리먼트. 이 엘리먼트가 이벤트 맵의
Selector와 일치하는 엘리먼트다. 이벤트가 전파하는 엘리먼트는 `target`과 그 조상이다.
{{/dtdd}}

{{#dtdd name="which" type="Number"}}
마우스 이벤트일 때는 어떤 마우스 버튼이 눌린 것인지를 나타낸다(1=left, 2=middle, 3=right).
키 이벤트일 때는 캐릭터나 키 코드를 의미한다.
{{/dtdd}}

{{#dtdd "stopPropagation()"}}
이벤트가 다른 엘리먼트에 전파되지 못하게 한다. 이 엘리먼트와 일치하는
핸들러가 또 있으면 그 핸들러는 호출된다. 핸들러가 속한 이벤트 맵은 상관없다.
{{/dtdd}}

{{#dtdd "stopImmediatePropagation()"}}
이 이벤트와 관련된 모든 이벤트 핸들러가 호출되지 못하게 한다. 이벤트가
전파됨에 따라 호출될 핸들러는 물론이고 해당 이벤트 맵과 다른 이벤트
맵에 속한 핸들러도 호출되지 않는다.
{{/dtdd}}

{{#dtdd "preventDefault()"}}
브라우저가 이 이벤트에 대해 동작하지 못하게 한다. 링크를 따라가거나
폼 데이터를 전송하는 일을 중지시킨다. 그래도 핸들러는 계속 호출되지만
결과를 취소할 수 없다.
{{/dtdd}}

{{#dtdd "isPropagationStopped()"}}
이 이벤트에 대해서 `stopPropagation()`을 호출한 적이 있는지 리턴한다.
{{/dtdd}}

{{#dtdd "isImmediatePropagationStopped()"}}
이 이벤트에 대해서 `stopImmediatePropagation()`을 호출한 적이 있는지 리턴한다.
{{/dtdd}}

{{#dtdd "isDefaultPrevented()"}}
이 이벤트에 대해서 `preventDefault()`을 호출한 적이 있는지 리턴한다.
{{/dtdd}}
</dl>

핸들러 함수가 `false`를 리턴하면 해당 이벤트에 `stopImmediatePropagation`과
`preventDefault`를 호출한 것과 같다.

이벤트 타입과 용법:

<dl class="objdesc">
{{#dtdd "<code>click</code>"}}
마우스 click 이벤트. 이 click 이벤트에 따라 브라우저가 동작하는 것을
중단시키려면 `preventDefault()`를 사용한다. 키보드로 엘리먼트를 활성화해서
`click` 이벤트를 발생시키는 방법도 있다.
{{/dtdd}}

{{#dtdd "<code>dblclick</code>"}}
Double-click.
{{/dtdd}}

{{#dtdd "<code>focus, blur</code>"}}
텍스트 입력 필드나 다른 폼 컨트롤이 포커스를 얻거나 잃으면 발생한다.
`tabindex` 프로퍼티를 주면 포커스를 가질 수 있는 엘리먼트가 된다.
브라우저는 링크, 체크박스, 라이오 버튼과 같이 태생적으로(natively)
포커스를 가질 수 있던 것과 구분한다. 그리고 이 이벤트는 전파되지 않는다.
{{/dtdd}}

{{#dtdd "<code>change</code>"}}
체크박스나 라디오 버튼의 상태가 변할 때 발생한다.
텍스트 필드에서는 `blur`나 키 이벤트를 사용하라.
{{/dtdd}}

{{#dtdd "<code>mouseenter, mouseleave</code>"}}
엘리먼트 영역에 마우스 포인터가 들어가거나 나올 때 발생한다.
이 이벤트는 전파되지 않는다.
{{/dtdd}}

{{#dtdd "<code>mousedown, mouseup</code>"}}
마우스 버튼을 누르거나 뗄 때 발생한다.
{{/dtdd}}

{{#dtdd "<code>keydown, keypress, keyup</code>"}}
이 이벤트는 사용자가 키보드 키를 누르면 발생한다.
텍스트 필드에서 입력하는 키가 뭔지 알고 싶을 때는
`keypress`가 좋고 `keydown`과 `keyup`은 방향 키와 특수 키에 좋다.
{{/dtdd}}
</dl>

다른 DOM 이벤트도 이용할 수 있지만, 위의 이벤트에 대해서는
브라우저마다 똑같이 동작하게 하려고 노력했다.

{{/api_box_inline}}

{{#api_box_inline constant}}

다시 렌더링하지 않는 Constant 영역임을 표시할 수 있다. `{{dstache}}#constant}}...{{dstache}}/constant}}` 블럭 헬퍼로 표시하면 된다. 템플릿이 다시 렌더링될 때 `#constant` 블럭 헬퍼에 들어 있는 내용은 그대로 유지된다. Preserve 엘리먼트처럼 해당 엘리먼트 근처에 있는 템플릿 엘리먼트만 패치한다. 노드를 선택적으로 유지하는 것과는 달리 이렇게 Constant 영역을 정의하면 해당 노드의 ID뿐만 아니라 속성과 내용까지 유지된다. 이 영역의 내용은 템플릿이 처음 렌더링될 때 딱 한 번 생성된다.

Constant 영역은 Meteor 템플릿에 Meteor 답지 않은(non-Meteor) 컨텐트을 넣을 때 사용한다. 개발자가 직접 다른 제 3의 위젯을 사용해서 화면을 만들고 관리할 때 사용하면 좋다. 보통 템플릿에 빈 엘리먼트를 넣는다. 템플릿을 하나 만들고 그 안에는 별 내용 없이 비워두었고 다른 위젯과 라이브러리로 그 템플릿 안에 엘리먼트를 채워 넣었었다고 하자. Meteor가 그 템플릿을 다시 랜더링할 때 원래 그 템플릿은 비워져 있었으므로 나중에 만들어 넣은 엘리먼트를 제거해버린다. 그런데 `#constant` 블럭을 이용해서 감싸 놓으면 그대로 유지된다. 그 안에 어떤 DOM이 들어 있던지 상관없이 유지된다.

{{#note}}
Constant 영역은 non-Meteor 컨텐트를 넣으려고 사용한다. 이 Constant 영역 안에서는 이벤트 핸들러와 Reactive 의존성이 동작하지 않는다.
{{/note}}

{{/api_box_inline}}

{{#api_box_inline isolate}}

템플릿은 각각 별도의 Reactive 컨텍스트에서 실행한다. 템플릿이 Reactive 데이터 소스에 접근할 때 데이터 의존성이 만들어진다.
그래서 데이터가 변하면 템플릿은 통째로 다시 렌더링된다. 이 말은 어떻게 템플릿을 구성했는지에 따라 렌더링하는 단위가 결정된다는 뜻이다.

보통 렌더링 범위는 그렇게 중요한 게 아니다. 하지만, 꼼꼼하게 튜닝해서 최적화해야 한다면 `{{dstache}}#isolate}}...{{dstache}}/isolate}}`를 사용할 수 있다. 데이터 의존성은 `#isolate` 블럭에만 국한되며 이 블럭에서 데이터가 변경돼도 부모 템플릿까지 다시 렌더링하지 않는다. 이 블럭 헬퍼를 사용하면 별도의 템플릿으로 정의한 것과 같은 효과를 낼 수 있다.

{{/api_box_inline}}

<h2 id="timers"><span>Timers</span></h2>

Meteor는 현 요청의 사용자 같은 정보를 전역 변수에 저장한다.
그래서 제 값이 사용되게 하려면 `setTimeout`과 `setInterval`말고
`Meteor.setTimeout`과 `Meteor.setInterval`을 사용해야 한다.

이 함수들은 Javascript의 네이티브 함수와 똑같이 동작한다.
만약 네이티브 함수를 호출하면 오동작할 것이다.

{{> api_box setTimeout}}
{{> api_box setInterval}}
{{> api_box clearTimeout}}
{{> api_box clearInterval}}

<h2 id="meteor_deps"><span>Meteor.deps</span></h2>

Meteor에는 의존성 추적 시스템이 있어서 [`Session`](#session) 변수가
수정되거나 DB 질의 결과가 달라지면 자동으로 템플릿을 다시 렌더링한다. 

다른 추적 시스템과 다르게 이 시스템은 손으로 의존성을 정의하지 않아도
그냥 동작한다. 메커니즘은 단순하지만 효과적이다. DB 쿼리처럼
Reactive 업데이트를 지원하는 함수를 호출할 때 자동으로 "무효화 컨텍스트"
객체를 전부 저장한다. 템플릿을 렌더링할 때에도 그 함수가 호출된다.
나중에 데이터가 변경되면 저장한 컨텍스트를 무효화한다.
그래서 템플릿은 다시 렌더링된다. 이 기능은 기껏해야 50라인 정도뿐이다.

개발자나 패키지 제작자는 *무효화 컨텍스트*를 사용해서 Reactive
데이터 소스를 추가하고 Reactive 데이터 소스의 의존성을 자동으로
등록하는 함수도 구현할 수 있다.

{{> api_box Context }}

이 생성자로 무효화 컨텍스트를 만들고 [`run`](#run) 함수로 무효화 컨텍스트
안에서 코드를 실행한다. 그리고 [`onInvalidate`](#onInvalidate)로 콜백을
등록하면 다시 실행돼야 할 때 그 콜백이 실행된다.

전역 변수 [`Meteor.deps.Context.current`](#current)을 확인하면 무효화 컨텍스트
안에서 실행하는 건지 아닌지 알 수 있다. 컨텍스트 밖에서 그 변수의 값은 `null`이
된다. Reactivity 시스템을 만들 때는 컨텍스트를 저장하게 하여야 한다.
그래야 나중에 뭔가 변경이 생겨서 [`invalidate`](#invalidate)를 호출할 때 그
컨텍스트를 다시 실행할 수 있다. 이렇게 하면 [`onInvalidate`](#onInvalidate)으로
cleanup 함수를 설정해서 추적을 언제 멈추는지 알 수 있다.

무효화 컨텍스트에는 양의 정수인 id가 부여된다. 편한 대로 아무 데나
저장해서 사용할 수 있다. 무효화 컨텍스트 프로퍼티에 저장해도 된다.
굳이 `_`를 이름 앞뒤로 붙일 필요도 없다.

{{> api_box run }}

이 함수는 단순히 [`Meteor.deps.Context.current`](#current)가 현 무효화
컨텍스트를 가리키게 하고, `func`를 실행하고, 이전 값으로 다시 되돌릴 뿐이다.
이 함수는 `func`가 리턴하는 값을 리턴한다.

run을 Recursive하게 호출해도 되며 `current`는 항상 가장 안쪽의 컨텍스트를 가리킨다.

{{> api_box onInvalidate }}

이 컨텍스트가 아직 무효화되지 않았으면 `callback`을 [`invalidate`](#invalidate)가
호출될 때 호출되는 함수 목록에 추가한다.
컨텍스트가 이미 무효화 됐으면 `callback`은 즉시 호출된다.

다음과 같은 유형의 Caller가 이 함수를 호출한다:

* 무효화 컨텍스트를 만드는 함수는 `onInvalidate` 콜백을 사용해서 컨텍스트에서
  코드를 재실행하도록 신호를 준다. 코드를 재실행하려면 무효화 컨텍스트를 새로
  만들고 `onInvalidate` 콜백을 다시 등록해야 한다.
  컨텍스트가 무효화될 때마다 이 과정이 반복된다.

* Reactive 데이터 소스인 함수는 [`Meteor.deps.Context.current`](#current)를
  일종의 리스너 목록에 저장한다. 그리고 그 함수는 `onInvalidate` 콜백을
  사용해서 리스트 목록에서 컨텍스트를 제거한다.

예제:

    // Print the current username to the console.  Will re-run every time
    // the username changes.
    var logCurrentUsername = function () {
      var update = function () {
        var ctx = new Meteor.deps.Context();  // invalidation context
        ctx.onInvalidate(update);         // rerun update() on invalidation
        ctx.run(function () {
          var username = Session.get("username");
          console.log("The current username is now", username);
        });
      };
      update();
    };

    // Example use. Since Session is reactive (meaning that it knows how
    // to use Meteor.deps to record its dependencies), logCurrentUsername
    // will be re-run whenever Session.set is called for "username".
    Session.set("username", "matt");
    logCurrentUsername(); // prints matt
    Session.set("username", "geoff"); // immediately prints geoff
    Session.set("username", "geoff"); // won't print: Session won't trigger
                                      // invalidation if the value is the same.

{{> api_box invalidate }}

무효화 상태에서는 `invalidate` 함수를 호출한들 아무 일도 일어나지 않는다
(수학적으로 "멱등(idempotent)"이라고 부른다). 무효화 상태가 아니면 
해당 컨텍스트에 [`onInvalidate`](#onInvalidate)로 등록한 함수를 모두 실행한다.

`invalidate` 함수가 호출되자마자 [`onInvalidate`](#onInvalidate) 함수가
바로 실행되는 것이 아니라 [`Meteor.flush`](#meteor_flush)가 실행할 때 호출된다.
`invalidate` 함수는 컨텍스트를 flush 목록에 추가하고 그 외에 별로 하는 게 없다.

[`Meteor.flush`](#meteor_flush)는 직접 호출하지 않아도 하던 일을 다 마치면
(다음 tick에) 자동으로 호출된다. delay 값을 0으로 주고 `setTimeout`
함수를 호출해서 다음 tick에 실행되는 것이다.

예제:

    // Create a simple class called Weather that tracks the current
    // temperature. The temperature can be read reactively.
    var Weather = function () {
      this.temperature = 60;
      this.listeners = {};
    };

    // Function to get the temperature (and, if called in a reactive
    // context, start listening for changes to the temperature.)
    Weather.prototype.getTemp = function () {
      var context = Meteor.deps.Context.current;

      // If we're inside a context, and it's not yet listening to
      // temperature changes..
      if (context && !this.listeners[context.id]) {
        // .. add it to our list of contexts that care about the temperature ..
        this.listeners[context.id] = context;

        // .. and remember to take it off our list when it goes away.
        var self = this;
        context.onInvalidate(function () {
          delete self.listeners[context.id];
        });
      }

      // return the current temperature, whether or not in a reactive context.
      return this.temperature;
    };

    // Function to set the temperature, and notify anyone that might be
    // listening for temperature updates.
    Weather.prototype.setTemp = function (newTemp) {
      if (this.temperature === newTemp)
        return; // don't want to trigger invalidation if there's no change.

      // Set the temperature
      this.temperature = newTemp;

      // Notify any contexts that care about temperature changes
      for (var contextId in this.listeners)
        // This will trigger the onInvalidate function above, but not
        // immediately -- only when Meteor.flush() is called, or at the end
        // of the event loop. So we know that this.listeners will be
        // emptied, but it won't change while we're trying to loop over it.
        this.listeners[contextId].invalidate();
    };

{{> api_box current }}

이 변수는 [`run`](#run) 함수가 설정하는 전역 변수다.

이 변수는 Lisp이나 프로그래밍 언어 이론에 나오는 dynamically scoped
변수라고 생각하면 된다. [`run`](#run)이 할당하고, 사용자 코드를
실행하고 나서 다시 이전 값으로 복원된다.

{{> api_box autorun }} 

`Meteor.autorun`은 개발자가 의존성 변화가 일어났을 때, 임의의 함수를 실행하는 자신만의 
reactive context를 만들 때 사용한다. 예를 들어 커서(reactive data source)를 
모니터링하거나 세션 변수와 같이 사용할 수도 있다.
 
    Meteor.autorun(function() { 
      var oldest = _.max(Monkeys.find().fetch(), function (monkey) { 
        return monkey.age; 
      }); 
      if (oldest) 
        Session.set("oldest", oldest.name); 
    }); 

아니면 세션 변수가 특정한 값을 얻을때까지 기다리는데에도 사용할 수 있다. 특정 값을 얻으면 
다음에 다시 실행하지 못하도록 핸들러의 `stop`메서드를 호출하는 예제가 아래에 있다.
 
    Meteor.autorun(function(handle) { 
      if (!Session.equals("shouldAlert", true)) return; 
      handle.stop(); 
      alert("Oh no!"); 
    }); 

아규먼트로 들어가는 이 함수는 다른 reactive source들 처럼 즉시 실행되고 그 뒤엔 
[`Meteor.flush`](#meteor_flush)가 실행될 때 마다 재 실행된다.


{{> api_box flush }}

일반적으로 데이터를 변경하고 DOM이 업데이트되려면 시스템이 idle이 될 때까지
기다려야 한다. 그래서 코드가 실행되자마자 DOM이 바뀌지 않는다.
이 전략은 Meteor를 더 빠르게 만들어준다.

`Meteor.flush`는 대기 중인 Reactive 업데이트를 강제로 완료시킨다
(DB의 변경된 내용을 DOM에 모두 적용시킨다). `flush`를 호출하면
대기 중인 변경사항이 즉시 적용된다. 이 함수는 최신 데이터에 DOM을 동기화
시키는 데 사용한다. 그래야 jQuery 같은 라이브러리를 써서 DOM을
수동으로 관리할 수 있다.

`flush`를 호출할 때, 화면에 없는 Reactive DOM 엘리먼트는 삭제된다.
Meteor가 엘리먼트를 추적하고 업데이트하는 것을 멈추기 때문에 브라우저의
Garbage Collector는 그 엘리먼트를 제거해버린다. 수동으로 `flush`를 호출하려면
[`Meteor.ui.render`](#meteor_ui_render)를 호출해서 만든 엘리먼트가
DOM 트리에 모두 넣어졌는지 꼭 확인해야 한다.

구체적으로 말해서, `flush`는 무효화된 [Reactive 컨텍스트](#context)의
[무효화 콜백](#onInvalidate)을 모두 호출한다. 모든
[Reactive 컨텍스트](#context)에 대해 호출하는 것은 아니고 아직
[무효화 콜백](#onInvalidate)이 호출되지 않은 컨텍스트만 해당된다.
flush는 실행해야 할 무효화 콜백이 전부 실행할 때까지 계속 실행 된다.
무효화시 [`Meteor.ui.render`](#meteor_ui_render)는 DOM 엘리먼트를 제거한다.

<h2 id="meteor_http"><span>Meteor.http</span></h2>

`Meteor.http`는 클라이언트와 서버에 둘 다 있는 HTTP API이다.
`$ meteor add http` 명령으로 프로젝트에 HTTP 패키지를 추가하면 사용할 수 있다.

{{> api_box httpcall}}

이 함수는 원격 서버에 HTTP Request를 보내는 함수이고 HTTP Response
컨텐트가 들어 있는 객체를 리턴한다. 리턴 받은 객체에 대한 설명은 아래에 이어진다.

서버에서는 이 함수를 비동기로도 사용할 수 있고 동기로도 사용할 수 있다.
콜백을 생략하면 동기로 호출돼서 요청이 완료돼야 결과를 리턴한다.
Meteor Method는 동기로 HTTP를 호출한 결과에 따라 성공할 수도 실패할
수도 있기 때문에 Method에서 서버에서 다른 서버의 HTTP API를 호출할 때 유용하다. 

HTTP와 HTTPS 프로토콜을 모두 지원한다. `url`을 아규먼트로 넘길 때
프로토콜과 호스트 이름이 모두 포함된 전체 URL을 넘겨야 한다. 그렇지만,
현재 호스트의 URL이면 상대 URL을 넘겨도 된다. `query` 옵션을 주면 `url`의
쿼리 스트링을 교체해버린다. `params` 옵션의 파라미터는 쿼리 스트링에
추가돼서 결국 URL에 덧붙여진다. 예를 들어, `url`은 `"/path?query"`이고
`params`이 `{foo:"bar"}`이면 결국 URL은 `"/path?query&foo=bar"`가 된다.

`params`은 Request 타입에 따라서 URL이나 Request 바디에 들어간다.
GET이나 HEAD같이 바디가 없는 Request에서는 파라미터가 URL에 들어간다.
POST나 그 외 다른 Request 타입에서는 파라미터가 `x-www-form-urlencoded`
컨텐트 타입으로 인코딩돼서 바디에 들어간다. 바디에 들어가는 `content`나
`data` 옵션을 주면 파라미터는 바디가 아니라 URL에 들어간다.

콜백에는 `error`와 `result` 아규먼트가 있다. Request가 실패하면 `error`
아규먼트에 Error가 들어간다. HTTP 상태 코드가 400나 500이거나, 네트워크
에러, 타임아웃일 때 모두 동일하다. `result`에는 항상 객체가 리턴된다.
동기 모드로 호출했으면 `rusult` 객체가 리턴되고 `error`는 `result`의 프로퍼티로 저장된다.

result 객체의 내용:

<dl class="objdesc">

<dt><span class="name">statusCode</span>
  <span class="type">Number</span></dt>
<dd>HTTP 상태 코드, 에러가 있으면 null이다.</dd>

<dt><span class="name">content</span>
  <span class="type">String</span></dt>
<dd>HTTP Response 바디</dd>

<dt><span class="name">data</span>
  <span class="type">Object or null</span></dt>
<dd>response의 컨텐트 타입이 JSON이면 바디의 내용이 JSON 객체로 파싱된다.</dd>

<dt><span class="name">headers</span>
  <span class="type">Object</span></dt>
<dd>Response의 HTTP 헤더들</dd>

<dt><span class="name">error</span>
  <span class="type">Error</span></dt>
<dd>Request가 실패하면 Error 객체가 할당되고 콜백의 `error` 파리미터와 같다.</dd>

</dl>

서버 Method의 예:

    Meteor.methods({checkTwitter: function (userId) {
      this.unblock();
      var result = Meteor.http.call("GET", "http://api.twitter.com/xyz",
                                    {params: {user: userId}});
      if (result.statusCode === 200)
         return true
      return false;
    }});

비동기 HTTP 호출의 예:

    Meteor.http.call("POST", "http://api.twitter.com/xyz",
                     {data: {some: "json", stuff: 1}},
                     function (error, result) {
                       if (result.statusCode === 200) {
                         Session.set("twizzled", true);
                       }
                     });

{{> api_box http_get}}
{{> api_box http_post}}
{{> api_box http_put}}
{{> api_box http_del}}

<h2 id="email"><span>Email</span></h2>

`email` 패키지는 Meteor 앱에서 이메일을 보내는데에 사용한다. 이를 사용하려면,
`$ meteor add email` 를 입력해 email 패키지를 프로젝트에 추가한다.

서버는 메일을 보낼때 `MAIL_URL`환경 변수를 사용한다. 현재 Meteor는 SMTP만을 
지원한다. 따라서 환경 변수 `MAIL_URL`은 `smtp://USERNAME:PASSWORD@HOST:PORT/`의 
포멧이어야 한다. `meteor deploy`를 이용해서 디플로이 할 땐 `MAIL_URL`의 기본값이
현재 계정이 된다.([Mailgun](http://www.mailgun.com/)
를 이용함) 이 계정으로 하루에 200개의 메일을 보낼 수 있다. `process.env.MAIL_URL
`에 원하는 값을 할당해서 원하는 URL을 이용할 수 있다. 할당은 `Email.send`전에 해
야한다.

`MAIL_URL`이 설정되어 있지 않으면(예를 들어 앱이 자기 컴퓨터에서 돌아가고 있다거나) `Email.send`를 호출했을 때 이메일이 전달되는 대신 메세지가 표준 출력으로 출력된다.

{{> api_box email_send }}

`from`은 반드시 채워넣어야 하며, `to`와 `cc`, `bcc` 중 적어도 하나 이상은 채워넣
어야 한다. 다른 옵션은 필요하면 설정한다.

{{/better_markdown}}
</template>






<template name="api_box">
<div class="api {{bare}}">
<h3 id="{{id}}">
  <a class="name selflink" href="#{{id}}">{{{name}}}</a>
{{#if locus}}
  <span class="locus">{{locus}}</span>
{{/if}}
</h3>

<div class="desc">
{{#each descr}}{{#better_markdown}}{{{this}}}{{/better_markdown}}{{/each}}
</div>

{{#if args}}
<h4>Arguments</h4>
{{> api_box_args args}}
{{/if}}

{{#if options}}
<h4>Options</h4>
{{> api_box_args options}}
{{/if}}

{{#if body}}
{{#better_markdown}}{{{body}}}{{/better_markdown}}
{{/if}}

</div>

</template>



<template name="api_box_args">
<dl class="args">
{{#each this}}
<dt><span class="name">{{{name}}}</span>
  <span class="type">
    {{#if type_link}}
      <a href="#{{type_link}}">{{type}}</a>
    {{else}}
      {{type}}
    {{/if}}
  </span></dt>
<dd>{{#better_markdown}}{{{descr}}}{{/better_markdown}}</dd>
{{/each}}
</dl>
</template>


<template name="api_section_helper">
<h2 id="{{id}}"><a href="#{{id}}" class="selflink"><span>{{name}}</span></a></h2>
</template>

